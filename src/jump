!=============================================================================!
        module constants

          real, parameter :: zero    = 0.0000000000000000000d+00
          real, parameter :: pt25    = 2.5000000000000000000d-01
          real, parameter :: pt33    = 3.3333333333333333333d-01
          real, parameter :: pt5     = 5.0000000000000000000d-01
          real, parameter :: pt66    = 6.6666666666666666666d-01
          real, parameter :: one     = 1.0000000000000000000d+00
          real, parameter :: onept25 = 1.2500000000000000000d+00          
          real, parameter :: onept33 = 1.3333333333333333333d+00
          real, parameter :: onept5  = 1.5000000000000000000d+00
          real, parameter :: two     = 2.0000000000000000000d+00
          real, parameter :: three   = 3.0000000000000000000d+00
          real, parameter :: pi      = 3.1415926535897932385d+00
          real, parameter :: four    = 4.0000000000000000000d+00
          real, parameter :: five    = 5.0000000000000000000d+00
          real, parameter :: infty   = 1.0000000000000000000d+30

        end module constants
!=============================================================================!
!=============================================================================!
        subroutine dtcfl(nx, ny, u, v, c, m1l, m2l, n1l, n2l, detJ, &
                         dxi, deta, cflmax, loctime, iter, dtl)
!  
!  Compute the CFL and time step
!  
!=============================================================================!
        use constants
        implicit none

        integer :: nx, ny
        real :: u(nx,ny), v(nx,ny), c(nx,ny)
        real :: m1l(nx,ny), m2l(nx,ny), n1l(nx,ny), n2l(nx,ny), detJ(nx,ny)
        real :: dtl(nx,ny)
        real :: dxi, deta, cflmax
        integer :: loctime, iter
        
        real :: u1l, u2l, cl, dm, dn, cfl, cfll, dtlmax, delt
        integer :: i, j, ji, il, jl
        
        real :: cfla, cflc, cflal, cflcl
        integer :: ia, ja, ic, jc

        real :: vol, sxj, syj, sxi, syi
!=============================================================================!

!.... new way of computing CFL

        cfla = 0.0
        cflc = 0.0

        do j = 1, ny
          do i = 1, nx
          
            sxj =  n2l(i,j) * dxi / detJ(i,j)
            syj = -m2l(i,j) * dxi / detJ(i,j)
            
            sxi = -n1l(i,j) * deta / detJ(i,j)
            syi =  m1l(i,j) * deta / detJ(i,j)

            vol = dxi * deta / detJ(i,j)
            
            u1l = u(i,j)
            u2l = v(i,j)
            
            cl = c(i,j)
            
!.... acoustic CFL

            cflal = (abs( u1l * sxi + u2l * syi ) + &
                     abs( u1l * sxj + u2l * syj ) + &
                     cl * sqrt( sxi**2 + two * sxi * syi + syi**2 + &
                                sxj**2 + two * sxj * syj + syj**2 ) ) / vol

!.... use the acoustic CFL to scale the local time step

            dtl(i,j) = cflal  ! one + sqrt(detJ)
            
            if ( cflal .gt. cfla ) then
              cfla = cflal
              ia = i
              ja = j
            end if

!.... convective CFL

            cflcl = (abs( u1l * sxi + u2l * syi ) + &
                     abs( u1l * sxj + u2l * syj ) ) / vol

            if ( cflcl .gt. cflc) then
              cflc = cflcl
              ic = i
              jc = j
            end if
                                
          end do        ! loop on i
        end do          ! loop on j

        cfl = cfla              ! use the acoustic CFL
        
        delt = cflmax / cfl
        if (loctime.eq.0) then
          dtl  = delt
        else
          dtl  = cflmax / dtl
!         dtl  = delt * (one + sqrt(m1l(ja,ia) * n2l(ja,ia) - &
!                m2l(ja,ia) * n1l(ja,ia))) / dtl
        end if
                   
        if (.false.) then
          write(*,"  ('Maximum Acoustic CFL/dt   = ',1pe13.6, &
                & ' at (',i3,',',i3,')')") cfla, ia, ja
          write(*,"  ('Maximum Convective CFL/dt = ',1pe13.6, &
                & ' at (',i3,',',i3,')')") cflc, ic, jc
          write(*,"(/,'Delt = ',1pe13.6,'  CFL  = ',1pe13.6)") &
                delt, cfl*delt
          write(*,  "('CFLa = ',1pe13.6,'  CFLc = ',1pe13.6,/)") &
                cfla*delt, cflc*delt
        end if

!.... find the maximum dt

        if (loctime.eq.1) then
          dtlmax = zero
          do j = 1, ny
            do i = 1, nx
              if (dtl(i,j).gt.dtlmax) then
                ia = i
                ja = j
                dtlmax = dtl(i,j)
              end if
            end do
          end do
          write(80,"(i5,1x,1pe13.6,1x,2(1pe13.6,1x,i5,1x,i5,1x))") &
                iter, delt, dtlmax, ia, ja
        end if
        
        return
        end
!=============================================================================!
        subroutine error(name,msg)
!  
!       Generic error handler 
!  
!=============================================================================!
        implicit none
        
        integer loc
        character*80 name, msg

        loc = index(name,'$')-1
        write(*,"(/,'*****************************************************')")
        write(*,"('Error in --> ',a)") name(1:loc)
        loc = index(msg,'$')-1
        write(*,"('-----------> ',a)") msg(1:loc)
        write(*,"('*****************************************************',/)")
        
        call exit(1)
        
        stop
        end

subroutine exit()

  stop

end subroutine exit
!============================================================================!
        module global
!============================================================================!

!.... constants

        real, parameter :: zero    = 0.0000000000000000000d+00
        real, parameter :: pt25    = 2.5000000000000000000d-01
        real, parameter :: pt33    = 3.3333333333333333333d-01
        real, parameter :: pt5     = 5.0000000000000000000d-01
        real, parameter :: pt66    = 6.6666666666666666666d-01
        real, parameter :: one     = 1.0000000000000000000d+00
        real, parameter :: onept25 = 1.2500000000000000000d+00    
        real, parameter :: onept33 = 1.3333333333333333333d+00
        real, parameter :: onept5  = 1.5000000000000000000d+00
        real, parameter :: two     = 2.0000000000000000000d+00
        real, parameter :: three   = 3.0000000000000000000d+00
        real, parameter :: pi      = 3.1415926535897932385d+00
        real, parameter :: four    = 4.0000000000000000000d+00
        real, parameter :: five    = 5.0000000000000000000d+00
        real, parameter :: infty   = 1.0000000000000000000d+30

!.... flow variables

        real, allocatable :: phi(:,:), q(:,:,:)
        real, allocatable :: gphi(:,:,:), ggphi(:,:,:)
        real, allocatable :: A(:,:,:)
        real, allocatable :: uint(:), vint(:), cint(:)
        real, allocatable :: p(:,:), gp(:,:,:)

!$sgi distribute phi(*,block), q(*,*,block)
!$sgi distribute gphi(*,*,block), ggphi(*,*,block)
!$sgi distribute A(*,*,block)
!$sgi distribute p(*,block), g1p(*,block), g2p(*,block)

        real :: g1phil, g2phil
        real :: g11phil, g12phil, g22phil
        real :: rho, u, v, t, c, cinv, Mx, My

!.... linear system

        real, allocatable :: res(:,:), mat(:,:,:)
!$sgi distribute res(*,block), mat(*,*,block)
                
!.... wake cut treatment

        integer :: na, nb

!.... flags
#ifndef __GFORTRAN__
        integer, external :: iargc
#endif
        logical :: wakecut=.false.
        integer :: type=0
        integer, parameter :: mfile = 3 
        integer :: nfile=0, narg, iarg, ifile(mfile)
        character*80 :: arg 

!.... mesh

        integer :: i, j, k, idof
        integer :: nx, ny, nz, ndof=1, ny2
        real, allocatable :: xy(:,:,:), xi(:), eta(:)
!$sgi distribute xy(*,*,block)
        real :: dxi, deta, dxiinv, detainv, minJ

!.... time stepping

        real :: dtmax, cflmax
        real :: omega, sigma
        real, allocatable :: dtl(:,:)
!$sgi distribute dtl(*,block)
        integer :: loctime, iter, niter
        
!.... metrics

        real, allocatable :: m(:,:,:), detJ(:,:)
!$sgi distribute m(*,*,block), detJ(*,block)

!.... flow parameters

        real :: Re, Pr
        real :: Ma     = 0.1
        real :: gamma  = 1.4
        real :: gamma1 = 0.4
        real :: cv     = 716.5
        real :: cp     = 1003.1
        real :: Rgas   = 286.6
        real :: beta, lambda
        real :: circ   = 0.0
        
!.... boundary conditions and initial conditions

        integer :: restart
        integer :: left, right, bottom, top
        integer :: optx=-1, opty=-1
        logical :: xper=.false., yper=.false.
        logical :: lsym=.false., rsym=.false., bsym=.false., tsym=.false.
        logical :: carp=.false.
        integer :: bx, by

!.... sponge variables

        integer :: ispg, Ns = 4
        real    :: As, xs = 0.0, xt = 1.0
        real, allocatable :: spg(:,:), phis(:,:)
!$sgi distribute spg(*,block), phis(*,block)

!.... smoother variables

        real :: eps_e

!.... residual statistics

        real    :: norm, resl, resmax, resmin, dvmax
        integer :: im, jm, in, jn, io, jo

!.... error handler

        integer :: ier

        end module global
!=============================================================================!
        subroutine grad( ndof, nx, ny, v, gv, dx, dy, optx, opty, &
                         xper, yper, lsym, rsym, bsym, tsym, carp)
!
!  Take the gradient of a 2-D field.
!  Updated to sixth-order accurate differencing on the interior with
!  the option for optimized fourth-order differencing.
!
!  Revised: 6-28-95
!
!=============================================================================!
        use stencil
        implicit none
        
        integer :: ndof, nx, ny, optx, opty
        logical :: xper, yper
        logical :: lsym, rsym, bsym, tsym, carp
        real    :: v(ndof,nx,ny), gv(2,ndof,nx,ny)
        !$sgi distribute v(*,*,block), gv(*,*,*,block)

        real    :: dx, dy
        
        real, parameter :: zero = 0.0, one = 1.0, pt5 = 0.5
        real dxinv, dyinv
        real a, b, c, w
        real gx1, gx2, gx3, gx4, gx5, gx6
        real gy1, gy2, gy3, gy4, gy5, gy6
        
        integer :: i, j, idof
        integer :: immm,imm,im,ip,ipp,ippp
        integer :: jmmm,jmm,jm,jp,jpp,jppp

        real, parameter :: eps = 1.0e-12
        real :: isign
!=============================================================================!

        dxinv  = one / dx
        dyinv  = one / dy

!.... seven point stencil in x

        if (optx.eq.0) then
          c = 1.0 / 60.0
        else if (optx.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = (w/2.0 - 2.0*Sin(w)/3.0 + Sin(2.0*w)/12.0) / &
              (5.0*Sin(w) - 4.0*Sin(2.0*w) + Sin(3.0*w))
        end if
        
        a = (2.0 + 15.0 * c) / 3.0
        b = -(1.0 + 48.0 * c) / 12.0

        gx1 =  -c * dxinv
        gx2 =  -b * dxinv
        gx3 =  -a * dxinv
        gx4 =   a * dxinv
        gx5 =   b * dxinv
        gx6 =   c * dxinv

!.... seven point stencil in y

        if (opty.eq.0) then
          c = 1.0 / 60.0
        else if (opty.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = (w/2.0 - 2.0*Sin(w)/3.0 + Sin(2.0*w)/12.0) / &
              (5.0*Sin(w) - 4.0*Sin(2.0*w) + Sin(3.0*w))
        end if
        
        a = (2.0 + 15.0 * c) / 3.0
        b = -(1.0 + 48.0 * c) / 12.0

        gy1 =  -c * dyinv
        gy2 =  -b * dyinv
        gy3 =  -a * dyinv
        gy4 =   a * dyinv
        gy5 =   b * dyinv
        gy6 =   c * dyinv

!=============================================================================!
!.... compute the gradient in x
!=============================================================================!

!.... interior

!$doacross local(i,idof)
!$omp parallel do private(i,immm,imm,im,ip,ipp,ippp,idof)
        do j = 1, ny
          do i = 4, nx-3
            immm = 1+mod(i-3-1,nx-1)
            imm  = 1+mod(i-2-1,nx-1)
            im   = 1+mod(i-1-1,nx-1)
            ip   = 1+mod(i+1-1,nx-1)
            ipp  = 1+mod(i+2-1,nx-1)
            ippp = 1+mod(i+3-1,nx-1)
            do idof = 1, ndof
              gv(1,idof,i,j)  = (gx1 * v(idof,immm,j)   + &
                                 gx2 * v(idof,imm,j)    + &
                                 gx3 * v(idof,im,j)     + &
                                 gx4 * v(idof,ip,j)     + &
                                 gx5 * v(idof,ipp,j)    + &
                                 gx6 * v(idof,ippp,j)   ) 
            end do
          end do
        end do
!$omp end parallel do 

!.... boundaries

        if (xper) then

!$doacross
!$omp parallel do
          do j = 1, ny

          gv(1,:,1,j)        = ( gx1 * v(:,nx-3,j)      + &
                                gx2 * v(:,nx-2,j)       + &
                                gx3 * v(:,nx-1,j)       + &
                                gx4 * v(:,2,j)          + &
                                gx5 * v(:,3,j)          + &
                                gx6 * v(:,4,j)  ) 
  
          gv(1,:,2,j)        = ( gx1 * v(:,nx-2,j)      + &
                                gx2 * v(:,nx-1,j)       + &
                                gx3 * v(:,1,j)          + &
                                gx4 * v(:,3,j)          + &
                                gx5 * v(:,4,j)          + &
                                gx6 * v(:,5,j)  ) 
  
          gv(1,:,3,j)        = ( gx1 * v(:,nx-1,j)      + &
                                gx2 * v(:,1,j)          + &
                                gx3 * v(:,2,j)          + &
                                gx4 * v(:,4,j)          + &
                                gx5 * v(:,5,j)          + &
                                gx6 * v(:,6,j)  ) 
  
          gv(1,:,nx-2,j)     = ( gx1 * v(:,nx-5,j)      + &
                                gx2 * v(:,nx-4,j)       + &
                                gx3 * v(:,nx-3,j)       + &
                                gx4 * v(:,nx-1,j)       + &
                                gx5 * v(:,1,j)          + &
                                gx6 * v(:,2,j)  ) 
  
          gv(1,:,nx-1,j)     = ( gx1 * v(:,nx-4,j)      + &
                                gx2 * v(:,nx-3,j)       + &
                                gx3 * v(:,nx-2,j)       + &
                                gx4 * v(:,1,j)          + &
                                gx5 * v(:,2,j)          + &
                                gx6 * v(:,3,j)  ) 
  
          gv(1,:,nx,j) = gv(1,:,1,j)

          end do
!$omp end parallel do 
          
        else

!.... left boundary

        if (lsym) then
!$doacross local( idof, isign )
!$omp parallel do private(idof, isign)
          do j = 1, ny
          do idof = 1, ndof
            if (idof .eq. 3) then
              isign = -one
            else
              isign = one
            end if
  
            gv(1,idof,1,j)     = ( isign * gx1 * v(idof,4,j)    + &
                                  isign * gx2 * v(idof,3,j)     + &
                                  isign * gx3 * v(idof,2,j)     + &
                                  gx4 * v(idof,2,j)             + &
                                  gx5 * v(idof,3,j)             + &
                                  gx6 * v(idof,4,j)             ) 
    
            gv(1,idof,2,j)     = ( isign * gx1 * v(idof,3,j)    + &
                                  isign * gx2 * v(idof,2,j)     + &
                                  gx3 * v(idof,1,j)             + &
                                  gx4 * v(idof,3,j)             + &
                                  gx5 * v(idof,4,j)             + &
                                  gx6 * v(idof,5,j)             ) 
    
            gv(1,idof,3,j)     = ( isign * gx1 * v(idof,2,j)    + &
                                  gx2 * v(idof,1,j)             + &
                                  gx3 * v(idof,2,j)             + &
                                  gx4 * v(idof,4,j)             + &
                                  gx5 * v(idof,5,j)             + &
                                  gx6 * v(idof,6,j)             ) 
          end do
          end do
!$omp end parallel do 

        else if (carp) then       ! Carpenter's boundary stencil

!$doacross
!$omp parallel do
          do j = 1, ny

          gv(1,:,1,j)     = ( gg1 * v(:,1,j)    + &
                             gg2 * v(:,2,j)     + &
                             gg3 * v(:,3,j)     + &
                             gg4 * v(:,4,j)     + &
                             gg5 * v(:,5,j)     + &
                             gg6 * v(:,6,j)  ) * dxinv
  
          gv(1,:,2,j)     = ( gh1 * v(:,1,j)    + &
                             gh2 * v(:,2,j)     + &
                             gh3 * v(:,3,j)     + &
                             gh4 * v(:,4,j)     + &
                             gh5 * v(:,5,j)     + &
                             gh6 * v(:,6,j)  ) * dxinv

          gv(1,:,3,j)     = ( gi1 * v(:,1,j)    + &
                             gi2 * v(:,2,j)     + &
                             gi3 * v(:,3,j)     + &
                             gi4 * v(:,4,j)     + &
                             gi5 * v(:,5,j)     + &
                             gi6 * v(:,6,j)  ) * dxinv

          gv(1,:,4,j)     = ( gj1 * v(:,1,j)    + &
                             gj2 * v(:,2,j)     + &
                             gj3 * v(:,3,j)     + &
                             gj4 * v(:,4,j)     + &
                             gj5 * v(:,5,j)     + &
                             gj6 * v(:,6,j)  ) * dxinv

          end do
          
        else

!$doacross
!$omp parallel do
          do j = 1, ny         ! standard boundary differences

          gv(1,:,1,j)      = ( gc1 * v(:,1,j)  + &
                              gc2 * v(:,2,j)  + &
                              gc3 * v(:,3,j)  + &
                              gc4 * v(:,4,j)  + &
                              gc5 * v(:,5,j)  ) * dxinv

          gv(1,:,2,j)      = ( gb1 * v(:,1,j)  + &
                              gb2 * v(:,2,j)  + &
                              gb3 * v(:,3,j)  + &
                              gb4 * v(:,4,j)  + &
                              gb5 * v(:,5,j)  ) * dxinv

          gv(1,:,3,j)      = ( ga1 * v(:,1,j)  + &
                              ga2 * v(:,2,j)  + &
                              ga3 * v(:,4,j)  + &
                              ga4 * v(:,5,j)  ) * dxinv

        end do

        end if

        if (rsym) then
!$doacross local( idof, isign )
!$omp parallel do private(idof, isign)
          do j = 1, ny
          do idof = 1, ndof
            if (idof .eq. 3) then
              isign = -one
            else
              isign = one
            end if
  
            gv(1,idof,nx-2,j)  = ( gx1 * v(idof,nx-5,j)         + &
                                  gx2 * v(idof,nx-4,j)          + &
                                  gx3 * v(idof,nx-3,j)          + &
                                  gx4 * v(idof,nx-1,j)          + &
                                  gx5 * v(idof,nx,  j)          + &
                                  isign * gx6 * v(idof,nx-1,j)  ) 
    
            gv(1,idof,nx-1,j)  = ( gx1 * v(idof,nx-4,j)         + &
                                  gx2 * v(idof,nx-3,j)          + &
                                  gx3 * v(idof,nx-2,j)          + &
                                  gx4 * v(idof,nx,  j)          + &
                                  isign * gx5 * v(idof,nx-1,j)  + &
                                  isign * gx6 * v(idof,nx-2,j)  ) 
    
            gv(1,idof,nx,j)    = ( gx1 * v(idof,nx-3,j)         + &
                                  gx2 * v(idof,nx-2,j)          + &
                                  gx3 * v(idof,nx-1,j)          + &
                                  isign * gx4 * v(idof,nx-1,j)  + &
                                  isign * gx5 * v(idof,nx-2,j)  + &
                                  isign * gx6 * v(idof,nx-3,j)  ) 
          end do
          end do
!$omp end parallel do 

        else if (carp) then       ! Carpenter's boundary stencil

!$doacross
!$omp parallel do
          do j = 1, ny

          gv(1,:,nx-3,j) = -( gj1 * v(:,nx,j)   + &
                             gj2 * v(:,nx-1,j)  + &
                             gj3 * v(:,nx-2,j)  + &
                             gj4 * v(:,nx-3,j)  + &
                             gj5 * v(:,nx-4,j)  + &
                             gj6 * v(:,nx-5,j)  ) * dxinv

          gv(1,:,nx-2,j) = -( gi1 * v(:,nx,j)   + &
                             gi2 * v(:,nx-1,j)  + &
                             gi3 * v(:,nx-2,j)  + &
                             gi4 * v(:,nx-3,j)  + &
                             gi5 * v(:,nx-4,j)  + &
                             gi6 * v(:,nx-5,j)  ) * dxinv

          gv(1,:,nx-1,j) = -( gh1 * v(:,nx,j)   + &
                             gh2 * v(:,nx-1,j)  + &
                             gh3 * v(:,nx-2,j)  + &
                             gh4 * v(:,nx-3,j)  + &
                             gh5 * v(:,nx-4,j)  + &
                             gh6 * v(:,nx-5,j)  ) * dxinv

          gv(1,:,nx,j)   = -( gg1 * v(:,nx,j)   + &
                             gg2 * v(:,nx-1,j)  + &
                             gg3 * v(:,nx-2,j)  + &
                             gg4 * v(:,nx-3,j)  + &
                             gg5 * v(:,nx-4,j)  + &
                             gg6 * v(:,nx-5,j)  ) * dxinv
          end do
!$omp end parallel do 

        else                     ! standard boundary differences
        
!$doacross
!$omp parallel do
          do j = 1, ny  
          gv(1,:,nx-2,j)   = ( ga1 * v(:,nx-4,j)  + &
                              ga2 * v(:,nx-3,j)  + &
                              ga3 * v(:,nx-1,j)  + &
                              ga4 * v(:,nx  ,j)  ) * dxinv
  
          gv(1,:,nx-1,j)  = -( gb1 * v(:,nx  ,j)  + &
                              gb2 * v(:,nx-1,j)  + &
                              gb3 * v(:,nx-2,j)  + &
                              gb4 * v(:,nx-3,j)  + &
                              gb5 * v(:,nx-4,j)  ) * dxinv
  
          gv(1,:,nx,j)    = -( gc1 * v(:,nx  ,j)  + &
                              gc2 * v(:,nx-1,j)  + &
                              gc3 * v(:,nx-2,j)  + &
                              gc4 * v(:,nx-3,j)  + &
                              gc5 * v(:,nx-4,j)  ) * dxinv

          end do
!$omp end parallel do 

        end if

      end if
!=============================================================================!
!.... compute the gradient in y
!=============================================================================!

!.... interior

!$doacross local(j,idof)
!$omp parallel do private(i,j,jmmm,jmm,jm,jp,jpp,jppp,idof)
        do j = 1, ny
!!$       jmmm = max(j-3,1)
!!$       jmm  = max(j-2,1)
!!$       jm   = max(j-1,1)
!!$       jp   = min(j+1,ny)
!!$       jpp  = min(j+2,ny)
!!$       jppp = min(j+3,ny)

          jmmm = 1+mod(j-3-1,ny-1)
          jmm  = 1+mod(j-2-1,ny-1)
          jm   = 1+mod(j-1-1,ny-1)
          jp   = 1+mod(j+1-1,ny-1)
          jpp  = 1+mod(j+2-1,ny-1)
          jppp = 1+mod(j+3-1,ny-1)

          do i = 1, nx
            do idof = 1, ndof
              gv(2,idof,i,j) = ( gy1 * v(idof,i,jmmm) + &
                                 gy2 * v(idof,i,jmm)  + &
                                 gy3 * v(idof,i,jm)   + &
                                 gy4 * v(idof,i,jp)   + &
                                 gy5 * v(idof,i,jpp)  + &
                                 gy6 * v(idof,i,jppp)   ) 
            end do
          end do
        end do
!$omp end parallel do 

!.... boundaries

        if (yper) then
        
!$doacross
!$omp parallel do
          do i = 1, nx

          gv(2,:,i,1)        = ( gy1 * v(:,i,ny-3)      + &
                                gy2 * v(:,i,ny-2)       + &
                                gy3 * v(:,i,ny-1)       + &
                                gy4 * v(:,i,2)          + &
                                gy5 * v(:,i,3)          + &
                                gy6 * v(:,i,4)          ) 
  
          gv(2,:,i,2)        = ( gy1 * v(:,i,ny-2)      + &
                                gy2 * v(:,i,ny-1)       + &
                                gy3 * v(:,i,1)          + &
                                gy4 * v(:,i,3)          + &
                                gy5 * v(:,i,4)          + &
                                gy6 * v(:,i,5)  ) 
  
          gv(2,:,i,3)        = ( gy1 * v(:,i,ny-1)      + &
                                gy2 * v(:,i,1)          + &
                                gy3 * v(:,i,2)          + &
                                gy4 * v(:,i,4)          + &
                                gy5 * v(:,i,5)          + &
                                gy6 * v(:,i,6)  ) 
  
          gv(2,:,i,ny-2)     = ( gy1 * v(:,i,ny-5)      + &
                                gy2 * v(:,i,ny-4)       + &
                                gy3 * v(:,i,ny-3)       + &
                                gy4 * v(:,i,ny-1)       + &
                                gy5 * v(:,i,1)          + &
                                gy6 * v(:,i,2)  ) 
  
          gv(2,:,i,ny-1)     = ( gy1 * v(:,i,ny-4)      + &
                                gy2 * v(:,i,ny-3)       + &
                                gy3 * v(:,i,ny-2)       + &
                                gy4 * v(:,i,1)          + &
                                gy5 * v(:,i,2)          + &
                                gy6 * v(:,i,3)  ) 
  
          gv(2,:,i,ny) = gv(2,:,i,1)

          end do
!$omp end parallel do 

        else if (bsym .or. tsym) then

          call error('grad$','Bsym and Tsym flags not implemented$')

        else if (carp ) then       !  Implement Carpenter's boundary stencil

!$doacross
!$omp parallel do
          do i = 1, nx

          gv(2,:,i,1)     = ( gg1 * v(:,i,1)    + &
                             gg2 * v(:,i,2)     + &
                             gg3 * v(:,i,3)     + &
                             gg4 * v(:,i,4)     + &
                             gg5 * v(:,i,5)     + &
                             gg6 * v(:,i,6)  ) * dyinv
  
          gv(2,:,i,2)     = ( gh1 * v(:,i,1)    + &
                             gh2 * v(:,i,2)     + &
                             gh3 * v(:,i,3)     + &
                             gh4 * v(:,i,4)     + &
                             gh5 * v(:,i,5)     + &
                             gh6 * v(:,i,6)  ) * dyinv

          gv(2,:,i,3)     = ( gi1 * v(:,i,1)    + &
                             gi2 * v(:,i,2)     + &
                             gi3 * v(:,i,3)     + &
                             gi4 * v(:,i,4)     + &
                             gi5 * v(:,i,5)     + &
                             gi6 * v(:,i,6)  ) * dyinv

          gv(2,:,i,4)     = ( gj1 * v(:,i,1)    + &
                             gj2 * v(:,i,2)     + &
                             gj3 * v(:,i,3)     + &
                             gj4 * v(:,i,4)     + &
                             gj5 * v(:,i,5)     + &
                             gj6 * v(:,i,6)  ) * dyinv

          gv(2,:,i,ny-3) = -( gj1 * v(:,i,ny)   + &
                             gj2 * v(:,i,ny-1)  + &
                             gj3 * v(:,i,ny-2)  + &
                             gj4 * v(:,i,ny-3)  + &
                             gj5 * v(:,i,ny-4)  + &
                             gj6 * v(:,i,ny-5)  ) * dyinv

          gv(2,:,i,ny-2) = -( gi1 * v(:,i,ny)   + &
                             gi2 * v(:,i,ny-1)  + &
                             gi3 * v(:,i,ny-2)  + &
                             gi4 * v(:,i,ny-3)  + &
                             gi5 * v(:,i,ny-4)  + &
                             gi6 * v(:,i,ny-5)  ) * dyinv

          gv(2,:,i,ny-1) = -( gh1 * v(:,i,ny)   + &
                             gh2 * v(:,i,ny-1)  + &
                             gh3 * v(:,i,ny-2)  + &
                             gh4 * v(:,i,ny-3)  + &
                             gh5 * v(:,i,ny-4)  + &
                             gh6 * v(:,i,ny-5)  ) * dyinv

          gv(2,:,i,ny)   = -( gg1 * v(:,i,ny)   + &
                             gg2 * v(:,i,ny-1)  + &
                             gg3 * v(:,i,ny-2)  + &
                             gg4 * v(:,i,ny-3)  + &
                             gg5 * v(:,i,ny-4)  + &
                             gg6 * v(:,i,ny-5)  ) * dyinv
          end do
!$omp end parallel do 

        else     ! normal boundary differences (must use for implicit)

!$doacross
!$omp parallel do
          do i = 1, nx

          gv(2,:,i,1)     = ( gc1 * v(:,i,1)    + &
                              gc2 * v(:,i,2)    + &
                              gc3 * v(:,i,3)    + &
                              gc4 * v(:,i,4)    + &
                              gc5 * v(:,i,5)     ) * dyinv
!!$
!!$       gv(2,:,i,1)     = ( gk1 * v(:,i,1)    + &
!!$                           gk2 * v(:,i,2)    + &
!!$                           gk3 * v(:,i,3)    ) * dyinv

          gv(2,:,i,2)     = ( gb1 * v(:,i,1)    + &
                              gb2 * v(:,i,2)    + &
                              gb3 * v(:,i,3)    + &
                              gb4 * v(:,i,4)    + &
                              gb5 * v(:,i,5)     ) * dyinv
  
          gv(2,:,i,3)     = ( ga1 * v(:,i,1)    + &
                              ga2 * v(:,i,2)    + &
                              ga3 * v(:,i,4)    + &
                              ga4 * v(:,i,5)     ) * dyinv
  
          gv(2,:,i,ny-2)  = ( ga1 * v(:,i,ny-4)  + &
                              ga2 * v(:,i,ny-3)  + &
                              ga3 * v(:,i,ny-1)  + &
                              ga4 * v(:,i,ny  )  ) * dyinv
  
          gv(2,:,i,ny-1) = -( gb1 * v(:,i,ny  )  + &
                              gb2 * v(:,i,ny-1)  + &
                              gb3 * v(:,i,ny-2)         + &
                              gb4 * v(:,i,ny-3)  + &
                              gb5 * v(:,i,ny-4)  ) * dyinv
  
          gv(2,:,i,ny)   = -( gc1 * v(:,i,ny  )  + &
                              gc2 * v(:,i,ny-1)  + &
                              gc3 * v(:,i,ny-2)  + &
                              gc4 * v(:,i,ny-3)  + &
                              gc5 * v(:,i,ny-4)  ) * dyinv
                            
          end do
!$omp end parallel do 

        end if
        
!.... implement a filter of roundoff noise

        if (.false.) then

!$omp parallel do private(i,idof)
          do j = 1, ny
            do i = 1, nx
              do idof = 1, ndof
                if ( abs(gv(1,idof,i,j)) .lt. eps ) gv(1,idof,i,j) = zero
                if ( abs(gv(2,idof,i,j)) .lt. eps ) gv(2,idof,i,j) = zero
              end do
            end do
          end do

        end if

        return
        end
!=============================================================================!
        subroutine grad2 (ndof, nx, ny, v, gv, ggv, dx, dy, &
                          optx, opty, xper, yper, lsym, rsym, bsym, tsym, carp)
!
!  Take the second derivative of a 2-D field.
!  Updated to sixth-order accurate differencing on the interior with
!  the option for optimized fourth-order differencing.
!
!  Added g1v as input to improve efficiency
!
!  Revised: 6-28-95
!=============================================================================!
        use stencil
        implicit none
        
        integer :: ndof, nx, ny, optx, opty
        logical :: xper, yper
        logical :: lsym, rsym, bsym, tsym, carp
        real    :: v(ndof,nx,ny), gv(2,ndof,nx,ny), ggv(3,ndof,nx,ny)
        !$sgi distribute v(*,*,block), gv(*,*,*,block), ggv(*,*,*,block)
        real    :: dx, dy

        real, parameter :: zero = 0.0, one = 1.0, pt5 = 0.5, two = 2.0
        real :: dxinv, dyinv, dxsinv, dysinv
        real :: a, b, c, w
        real :: gx1, gx2, gx3, gx4, gx5, gx6
        real :: gy1, gy2, gy3, gy4, gy5, gy6
        real :: dx1, dx2, dx3, dx4, dx5, dx6, dx7
        real :: dy1, dy2, dy3, dy4, dy5, dy6, dy7
        
        integer :: i, j, idof
        real, parameter :: eps = 1.0e-12
        real :: isign
!=============================================================================!

        dxinv  = one / dx
        dyinv  = one / dy
        dxsinv = one / dx**2
        dysinv = one / dy**2

!.... seven point stencil in x

        if (optx.eq.0) then
          c = 1.0 / 60.0
        else if (optx.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = (w/2.0 - 2.0*Sin(w)/3.0 + Sin(2.0*w)/12.0) / &
              (5.0*Sin(w) - 4.0*Sin(2.0*w) + Sin(3.0*w))
        end if
        
        a = (2.0 + 15.0 * c) / 3.0
        b = -(1.0 + 48.0 * c) / 12.0

        gx1 =  -c * dxinv
        gx2 =  -b * dxinv
        gx3 =  -a * dxinv
        gx4 =   a * dxinv
        gx5 =   b * dxinv
        gx6 =   c * dxinv

        if (optx.eq.0) then
          c = 1.0 / 90.0
        else if (optx.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = -(3.0*w**2 - 16.0*Sin(w/2.0)**2 + Sin(w)**2) / &
               (12.0*(-15.0*Sin(w/2.0)**2 + 6.0*Sin(w)**2 -  &
               Sin(3.0*w/2.0)**2))
        end if
        
        a = (4.0 + 45.0 * c) / 3.0
        b = -(1.0 + 72.0 * c) / 12.0

        dx1 =  c * dxsinv
        dx2 =  b * dxsinv
        dx3 =  a * dxsinv
        dx4 = -2.0 * ( a + b + c ) * dxsinv
        dx5 =  a * dxsinv
        dx6 =  b * dxsinv
        dx7 =  c * dxsinv

!.... seven point stencil in y

        if (opty.eq.0) then
          c = 1.0 / 60.0
        else if (opty.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = (w/2.0 - 2.0*Sin(w)/3.0 + Sin(2.0*w)/12.0) / &
              (5.0*Sin(w) - 4.0*Sin(2.0*w) + Sin(3.0*w))
        end if
        
        a = (2.0 + 15.0 * c) / 3.0
        b = -(1.0 + 48.0 * c) / 12.0

        gy1 =  -c * dyinv
        gy2 =  -b * dyinv
        gy3 =  -a * dyinv
        gy4 =   a * dyinv
        gy5 =   b * dyinv
        gy6 =   c * dyinv

        if (opty.eq.0) then
          c = 1.0 / 90.0
        else if (opty.eq.-1) then
          c = 0.0
        else
          w = 2.0 * 3.1415926535897932385e+0 / 12.0
          c = -(3.0*w**2 - 16.0*Sin(w/2.0)**2 + Sin(w)**2) / &
               (12.0*(-15.0*Sin(w/2.0)**2 + 6.0*Sin(w)**2 -  &
               Sin(3.0*w/2.0)**2))
        end if
        
        a = (4.0 + 45.0 * c) / 3.0
        b = -(1.0 + 72.0 * c) / 12.0

        dy1 =  c * dysinv
        dy2 =  b * dysinv
        dy3 =  a * dysinv
        dy4 = -2.0 * ( a + b + c ) * dysinv
        dy5 =  a * dysinv
        dy6 =  b * dysinv
        dy7 =  c * dysinv

!=============================================================================!
!.... compute the second derivative in x
!=============================================================================!

        if (xper) then

!$doacross
!$omp parallel do
          do j = 1, ny

          ggv(1,:,1,j)       = ( dx1 * v(:,nx-3,j)   + &
                                dx2 * v(:,nx-2,j)   + &
                                dx3 * v(:,nx-1,j)   + &
                                dx4 * v(:,1,j)      + &
                                dx5 * v(:,2,j)      + &
                                dx6 * v(:,3,j)      + &
                                dx7 * v(:,4,j)      ) 
  
          ggv(1,:,2,j)       = ( dx1 * v(:,nx-2,j)   + &
                                dx2 * v(:,nx-1,j)   + &
                                dx3 * v(:,1,j)      + &
                                dx4 * v(:,2,j)      + &
                                dx5 * v(:,3,j)      + &
                                dx6 * v(:,4,j)      + &
                                dx7 * v(:,5,j)      ) 
  
          ggv(1,:,3,j)       = ( dx1 * v(:,nx-1,j)   + &
                                dx2 * v(:,1,j)      + &
                                dx3 * v(:,2,j)      + &
                                dx4 * v(:,3,j)      + &
                                dx5 * v(:,4,j)      + &
                                dx6 * v(:,5,j)      + &
                                dx7 * v(:,6,j)      ) 
  
          ggv(1,:,nx-2,j)    = ( dx1 * v(:,nx-5,j)   + &
                                dx2 * v(:,nx-4,j)   + &
                                dx3 * v(:,nx-3,j)   + &
                                dx4 * v(:,nx-2,j)   + &
                                dx5 * v(:,nx-1,j)   + &
                                dx6 * v(:,1,j)      + &
                                dx7 * v(:,2,j)      ) 
  
          ggv(1,:,nx-1,j)    = ( dx1 * v(:,nx-4,j)   + &
                                dx2 * v(:,nx-3,j)   + &
                                dx3 * v(:,nx-2,j)   + &
                                dx4 * v(:,nx-1,j)   + &
                                dx5 * v(:,1,j)      + &
                                dx6 * v(:,2,j)      + &
                                dx7 * v(:,3,j)   ) 
  
          ggv(1,:,nx,j) = ggv(1,:,1,j)

          end do
          
        else
        
!$doacross
!$omp parallel do
          do j = 1, ny

          ggv(1,:,1,j)       = ( dd1 * v(:,1,j) + &
                                dd2 * v(:,2,j) + &
                                dd3 * v(:,3,j) + &
                                dd4 * v(:,4,j) + &
                                dd5 * v(:,5,j) ) * dxsinv
  
          ggv(1,:,2,j)       = ( db1 * v(:,1,j) + &
                                db2 * v(:,2,j) + &
                                db3 * v(:,3,j) + &
                                db4 * v(:,4,j) + &
                                db5 * v(:,5,j) ) * dxsinv
  
          ggv(1,:,3,j)       = ( da1 * v(:,1,j) + &
                                da2 * v(:,2,j) + &
                                da3 * v(:,3,j) + &
                                da4 * v(:,4,j) + &
                                da5 * v(:,5,j) ) * dxsinv
  
          ggv(1,:,nx-2,j)    = ( da1 * v(:,nx-4,j) + &
                                da2 * v(:,nx-3,j) + &
                                da3 * v(:,nx-2,j) + &
                                da4 * v(:,nx-1,j) + &
                                da5 * v(:,nx,j)   ) * dxsinv
  
          ggv(1,:,nx-1,j)    =   ( db1 * v(:,nx,j)   + &
                                  db2 * v(:,nx-1,j) + &
                                  db3 * v(:,nx-2,j) + &
                                  db4 * v(:,nx-3,j) + &
                                  db5 * v(:,nx-4,j) ) * dxsinv
  
          ggv(1,:,nx,j)      =   ( dd1 * v(:,nx,j)   + &
                                  dd2 * v(:,nx-1,j) + &
                                  dd3 * v(:,nx-2,j) + &
                                  dd4 * v(:,nx-3,j) + &
                                  dd5 * v(:,nx-4,j) ) * dxsinv

          end do

        end if
        
!.... implement symmetry conditions

        if (lsym) then
!$doacross local( idof, isign )
!$omp parallel do private( idof, isign )
          do j = 1, ny
          do idof = 1, ndof
            if (idof .eq. 3) then
              isign = -one
            else
              isign = one
            end if
            
            ggv(1,idof,1,j)    = ( isign * dx1 * v(idof,4,j)    + &
                                  isign * dx2 * v(idof,3,j)     + &
                                  isign * dx3 * v(idof,2,j)     + &
                                  dx4 * v(idof,1,j)             + &
                                  dx5 * v(idof,2,j)             + &
                                  dx6 * v(idof,3,j)             + &
                                  dx7 * v(idof,4,j)             ) 
    
            ggv(1,idof,2,j)    = ( isign * dx1 * v(idof,3,j)    + &
                                  isign * dx2 * v(idof,2,j)     + &
                                  dx3 * v(idof,1,j)             + &
                                  dx4 * v(idof,2,j)             + &
                                  dx5 * v(idof,3,j)             + &
                                  dx6 * v(idof,4,j)             + &
                                  dx7 * v(idof,5,j)             ) 
    
            ggv(1,idof,3,j)    = ( isign * dx1 * v(idof,2,j)    + &
                                  dx2 * v(idof,1,j)             + &
                                  dx3 * v(idof,2,j)             + &
                                  dx4 * v(idof,3,j)             + &
                                  dx5 * v(idof,4,j)             + &
                                  dx6 * v(idof,5,j)             + &
                                  dx7 * v(idof,6,j)             ) 
          end do
          end do

        end if

        if (rsym) then
!$doacross local( idof, isign )
!$omp parallel do private( idof, isign )
          do j = 1, ny
          do idof = 1, ndof
            if (idof .eq. 3) then
              isign = -one
            else
              isign = one
            end if
  
            ggv(1,idof,nx-2,j) = ( dx1 * v(idof,nx-5,j)         + &
                                  dx2 * v(idof,nx-4,j)          + &
                                  dx3 * v(idof,nx-3,j)          + &
                                  dx4 * v(idof,nx-2,j)          + &
                                  dx5 * v(idof,nx-1,j)          + &
                                  dx6 * v(idof,nx,j)            + &
                                  isign * dx7 * v(idof,nx-1,j)  ) 
    
            ggv(1,idof,nx-1,j) = ( dx1 * v(idof,nx-4,j)         + &
                                  dx2 * v(idof,nx-3,j)          + &
                                  dx3 * v(idof,nx-2,j)          + &
                                  dx4 * v(idof,nx-1,j)          + &
                                  dx5 * v(idof,nx,j)            + &
                                  isign * dx6 * v(idof,nx-1,j)  + &
                                  isign * dx7 * v(idof,nx-2,j)  ) 
    
            ggv(1,idof,nx,j)   = ( dx1 * v(idof,nx-3,j)         + &
                                  dx2 * v(idof,nx-2,j)          + &
                                  dx3 * v(idof,nx-1,j)          + &
                                  dx4 * v(idof,nx,j)            + &
                                  isign * dx5 * v(idof,nx-1,j)  + &
                                  isign * dx6 * v(idof,nx-2,j)  + &
                                  isign * dx7 * v(idof,nx-3,j)  ) 
          end do
          end do

        end if
        
!.... interior

!$doacross local(i,idof)
!$omp parallel do private(i,idof)
        do j = 1, ny
          do i = 4, nx-3
            do idof = 1, ndof
              ggv(1,idof,i,j) = ( dx1 * v(idof,i-3,j)   + &
                                 dx2 * v(idof,i-2,j)   + &
                                 dx3 * v(idof,i-1,j)   + &
                                 dx4 * v(idof,i,j)     + &
                                 dx5 * v(idof,i+1,j)   + &
                                 dx6 * v(idof,i+2,j)   + &
                                 dx7 * v(idof,i+3,j)   )
            end do
          end do
        end do

!=============================================================================!
!.... compute the second derivative in y
!=============================================================================!

        if (yper) then
        
!$doacross
!$omp parallel do
          do i = 1, nx

          ggv(3,:,i,1)       = ( dy1 * v(:,i,ny-3)   + &
                                dy2 * v(:,i,ny-2)   + &
                                dy3 * v(:,i,ny-1)   + &
                                dy4 * v(:,i,1)      + &
                                dy5 * v(:,i,2)      + &
                                dy6 * v(:,i,3)      + &
                                dy7 * v(:,i,4)      ) 
  
          ggv(3,:,i,2)       = ( dy1 * v(:,i,ny-2)   + &
                                dy2 * v(:,i,ny-1)   + &
                                dy3 * v(:,i,1)      + &
                                dy4 * v(:,i,2)      + &
                                dy5 * v(:,i,3)      + &
                                dy6 * v(:,i,4)      + &
                                dy7 * v(:,i,5)      ) 
  
          ggv(3,:,i,3)       = ( dy1 * v(:,i,ny-1)   + &
                                dy2 * v(:,i,1)      + &
                                dy3 * v(:,i,2)      + &
                                dy4 * v(:,i,3)      + &
                                dy5 * v(:,i,4)      + &
                                dy6 * v(:,i,5)      + &
                                dy7 * v(:,i,6)      ) 
  
          ggv(3,:,i,ny-2)    = ( dy1 * v(:,i,ny-5)   + &
                                dy2 * v(:,i,ny-4)   + &
                                dy3 * v(:,i,ny-3)   + &
                                dy4 * v(:,i,ny-2)   + &
                                dy5 * v(:,i,ny-1)   + &
                                dy6 * v(:,i,1)      + &
                                dy7 * v(:,i,2)      ) 
  
          ggv(3,:,i,ny-1)    = ( dy1 * v(:,i,ny-4)   + &
                                dy2 * v(:,i,ny-3)   + &
                                dy3 * v(:,i,ny-2)   + &
                                dy4 * v(:,i,ny-1)   + &
                                dy5 * v(:,i,1)      + &
                                dy6 * v(:,i,2)      + &
                                dy7 * v(:,i,3)   ) 
  
          ggv(3,:,i,ny) = ggv(3,:,i,1)

          end do

        else if (bsym .or. tsym) then

          call error('grad$','Bsym and Tsym flags not implemented$')

        else
        
!$doacross
!$omp parallel do
          do i = 1, nx

          ggv(3,:,i,1)      =  ( dd1 * v(:,i,1) + &
                                 dd2 * v(:,i,2) + &
                                 dd3 * v(:,i,3) + &
                                 dd4 * v(:,i,4) + &
                                 dd5 * v(:,i,5) ) * dysinv
!!$
!!$       ggv(3,:,i,1)      =  ( dk1 * v(:,i,1) + &
!!$                              dk2 * v(:,i,2) + &
!!$                              dk3 * v(:,i,3) ) * dysinv

          ggv(3,:,i,2)      =  ( db1 * v(:,i,1) + &
                                 db2 * v(:,i,2) + &
                                 db3 * v(:,i,3) + &
                                 db4 * v(:,i,4) + &
                                 db5 * v(:,i,5) ) * dysinv
  
          ggv(3,:,i,3)       = ( da1 * v(:,i,1) + &
                                 da2 * v(:,i,2) + &
                                 da3 * v(:,i,3) + &
                                 da4 * v(:,i,4) + &
                                 da5 * v(:,i,5) ) * dysinv
  
          ggv(3,:,i,ny-2)    = ( da1 * v(:,i,ny-4) + &
                                 da2 * v(:,i,ny-3) + &
                                 da3 * v(:,i,ny-2) + &
                                 da4 * v(:,i,ny-1) + &
                                 da5 * v(:,i,ny)   ) * dysinv
  
          ggv(3,:,i,ny-1)   =  ( db1 * v(:,i,ny)   + &
                                 db2 * v(:,i,ny-1) + &
                                 db3 * v(:,i,ny-2) + &
                                 db4 * v(:,i,ny-3) + &
                                 db5 * v(:,i,ny-4) ) * dysinv
  
          ggv(3,:,i,ny)     =  ( dd1 * v(:,i,ny)   + &
                                 dd2 * v(:,i,ny-1) + &
                                 dd3 * v(:,i,ny-2) + &
                                 dd4 * v(:,i,ny-3) + &
                                 dd5 * v(:,i,ny-4) ) * dysinv

          end do
                               
        endif

!.... interior

!$doacross local(j,idof)
!$omp parallel do private(j,idof)
        do i = 1, nx
          do j = 4, ny-3
            do idof = 1, ndof
              ggv(3,idof,i,j) = ( dy1 * v(idof,i,j-3)   + &
                                  dy2 * v(idof,i,j-2)   + &
                                  dy3 * v(idof,i,j-1)   + &
                                  dy4 * v(idof,i,j  )   + &
                                  dy5 * v(idof,i,j+1)   + &
                                  dy6 * v(idof,i,j+2)   + &
                                  dy7 * v(idof,i,j+3)   ) 
            end do
          end do
        end do

!
!=============================================================================!
!.... compute the cross derivative
!=============================================================================!

        if (yper) then
        
!$doacross
!$omp parallel do
          do i = 1, nx

          ggv(2,:,i,1)       = ( gy1 * gv(1,:,i,ny-3)   + &
                                gy2 * gv(1,:,i,ny-2)    + &
                                gy3 * gv(1,:,i,ny-1)    + &
                                gy4 * gv(1,:,i,2)       + &
                                gy5 * gv(1,:,i,3)       + &
                                gy6 * gv(1,:,i,4)       ) 
  
          ggv(2,:,i,2)       = ( gy1 * gv(1,:,i,ny-2)   + &
                                gy2 * gv(1,:,i,ny-1)    + &
                                gy3 * gv(1,:,i,1)       + &
                                gy4 * gv(1,:,i,3)       + &
                                gy5 * gv(1,:,i,4)       + &
                                gy6 * gv(1,:,i,5)       ) 
  
          ggv(2,:,i,3)       = ( gy1 * gv(1,:,i,ny-1)   + &
                                gy2 * gv(1,:,i,1)       + &
                                gy3 * gv(1,:,i,2)       + &
                                gy4 * gv(1,:,i,4)       + &
                                gy5 * gv(1,:,i,5)       + &
                                gy6 * gv(1,:,i,6)       ) 
  
          ggv(2,:,i,ny-2)    = ( gy1 * gv(1,:,i,ny-5)   + &
                                gy2 * gv(1,:,i,ny-4)    + &
                                gy3 * gv(1,:,i,ny-3)    + &
                                gy4 * gv(1,:,i,ny-1)    + &
                                gy5 * gv(1,:,i,1)       + &
                                gy6 * gv(1,:,i,2)       ) 
  
          ggv(2,:,i,ny-1)    = ( gy1 * gv(1,:,i,ny-4)   + &
                                gy2 * gv(1,:,i,ny-3)    + &
                                gy3 * gv(1,:,i,ny-2)    + &
                                gy4 * gv(1,:,i,1)       + &
                                gy5 * gv(1,:,i,2)       + &
                                gy6 * gv(1,:,i,3)       ) 
  
          ggv(2,:,i,ny) = ggv(2,:,i,1)

          end do

        else if (bsym .or. tsym) then

          call error('grad$','Bsym and Tsym flags not implemented$')

        else if (carp) then  ! Implement Carpenter's boundary stencil

!$doacross
!$omp parallel do
          do i = 1, nx

          ggv(2,:,i,1)    = ( gg1 * gv(1,:,i,1) + &
                             gg2 * gv(1,:,i,2)          + &
                             gg3 * gv(1,:,i,3)          + &
                             gg4 * gv(1,:,i,4)          + &
                             gg5 * gv(1,:,i,5)          + &
                             gg6 * gv(1,:,i,6)  ) * dyinv
  
          ggv(2,:,i,2)    = ( gh1 * gv(1,:,i,1)         + &
                             gh2 * gv(1,:,i,2)          + &
                             gh3 * gv(1,:,i,3)          + &
                             gh4 * gv(1,:,i,4)          + &
                             gh5 * gv(1,:,i,5)          + &
                             gh6 * gv(1,:,i,6)  ) * dyinv

          ggv(2,:,i,3)    = ( gi1 * gv(1,:,i,1)         + &
                             gi2 * gv(1,:,i,2)          + &
                             gi3 * gv(1,:,i,3)          + &
                             gi4 * gv(1,:,i,4)          + &
                             gi5 * gv(1,:,i,5)          + &
                             gi6 * gv(1,:,i,6)  ) * dyinv

          ggv(2,:,i,4)    = ( gj1 * gv(1,:,i,1)         + &
                             gj2 * gv(1,:,i,2)          + &
                             gj3 * gv(1,:,i,3)          + &
                             gj4 * gv(1,:,i,4)          + &
                             gj5 * gv(1,:,i,5)          + &
                             gj6 * gv(1,:,i,6)  ) * dyinv

          ggv(2,:,i,ny-3) =-( gj1 * gv(1,:,i,ny)    + &
                             gj2 * gv(1,:,i,ny-1)  + &
                             gj3 * gv(1,:,i,ny-2)  + &
                             gj4 * gv(1,:,i,ny-3)  + &
                             gj5 * gv(1,:,i,ny-4)  + &
                             gj6 * gv(1,:,i,ny-5)  ) * dyinv

          ggv(2,:,i,ny-2) =-( gi1 * gv(1,:,i,ny)    + &
                             gi2 * gv(1,:,i,ny-1)  + &
                             gi3 * gv(1,:,i,ny-2)  + &
                             gi4 * gv(1,:,i,ny-3)  + &
                             gi5 * gv(1,:,i,ny-4)  + &
                             gi6 * gv(1,:,i,ny-5)  ) * dyinv

          ggv(2,:,i,ny-1) =-( gh1 * gv(1,:,i,ny)    + &
                             gh2 * gv(1,:,i,ny-1)  + &
                             gh3 * gv(1,:,i,ny-2)  + &
                             gh4 * gv(1,:,i,ny-3)  + &
                             gh5 * gv(1,:,i,ny-4)  + &
                             gh6 * gv(1,:,i,ny-5)  ) * dyinv

          ggv(2,:,i,ny)   =-( gg1 * gv(1,:,i,ny)    + &
                             gg2 * gv(1,:,i,ny-1)  + &
                             gg3 * gv(1,:,i,ny-2)  + &
                             gg4 * gv(1,:,i,ny-3)  + &
                             gg5 * gv(1,:,i,ny-4)  + &
                             gg6 * gv(1,:,i,ny-5)  ) * dyinv

          end do

        else   ! normal boundary difference

!$doacross
!$omp parallel do
          do i = 1, nx

          ggv(2,:,i,1)     = ( gc1 * gv(1,:,i,1)  + &
                              gc2 * gv(1,:,i,2)  + &
                              gc3 * gv(1,:,i,3)  + &
                              gc4 * gv(1,:,i,4)  + &
                              gc5 * gv(1,:,i,5)  ) * dyinv
!!$  
!!$       ggv(2,:,i,1)    = ( gk1 * gv(1,:,i,1)  + &
!!$                           gk2 * gv(1,:,i,2)  + &
!!$                           gk3 * gv(1,:,i,3)  ) * dyinv
 
          ggv(2,:,i,2)     = ( gb1 * gv(1,:,i,1)  + &
                              gb2 * gv(1,:,i,2)  + &
                              gb3 * gv(1,:,i,3)  + &
                              gb4 * gv(1,:,i,4)  + &
                              gb5 * gv(1,:,i,5)  ) * dyinv
  
          ggv(2,:,i,3)     = ( ga1 * gv(1,:,i,1)  + &
                              ga2 * gv(1,:,i,2)  + &
                              ga3 * gv(1,:,i,4)  + &
                              ga4 * gv(1,:,i,5)  ) * dyinv
  
          ggv(2,:,i,ny-2)  = ( ga1 * gv(1,:,i,ny-4)  + &
                              ga2 * gv(1,:,i,ny-3)  + &
                              ga3 * gv(1,:,i,ny-1)  + &
                              ga4 * gv(1,:,i,ny  )  ) * dyinv
  
          ggv(2,:,i,ny-1) = -( gb1 * gv(1,:,i,ny  )  + &
                              gb2 * gv(1,:,i,ny-1)  + &
                              gb3 * gv(1,:,i,ny-2)  + &
                              gb4 * gv(1,:,i,ny-3)  + &
                              gb5 * gv(1,:,i,ny-4)  ) * dyinv
  
          ggv(2,:,i,ny)   = -( gc1 * gv(1,:,i,ny  )  + &
                              gc2 * gv(1,:,i,ny-1)  + &
                              gc3 * gv(1,:,i,ny-2)  + &
                              gc4 * gv(1,:,i,ny-3)  + &
                              gc5 * gv(1,:,i,ny-4)  ) * dyinv

          end do
                            
        end if
        
!.... interior

!$doacross local(j,idof)
!$omp parallel do private(j,idof)
        do i = 1, nx
          do j = 4, ny-3
            do idof = 1, ndof
              ggv(2,idof,i,j) = ( gy1 * gv(1,idof,i,j-3)        + &
                                 gy2 * gv(1,idof,i,j-2) + &
                                 gy3 * gv(1,idof,i,j-1) + &
                                 gy4 * gv(1,idof,i,j+1) + &
                                 gy5 * gv(1,idof,i,j+2) + &
                                 gy6 * gv(1,idof,i,j+3) ) 
            end do
          end do
        end do

!.... implement a filter of roundoff noise

        if (.false.) then

!$doacross local(i,idof)
!$omp parallel do private(i,idof)
        do j = 1, ny
          do i = 1, nx
            do idof = 1, ndof
              if ( abs(ggv(1,idof,i,j)) .lt. eps ) ggv(1,idof,i,j) = zero
              if ( abs(ggv(2,idof,i,j)) .lt. eps ) ggv(2,idof,i,j) = zero
              if ( abs(ggv(3,idof,i,j)) .lt. eps ) ggv(3,idof,i,j) = zero
            end do
          end do
        end do
        
        end if

        return
        end
function field(il,jl)
  use global
  implicit none

  real :: field
  integer :: il, jl

  field = xy(1,il,jl) + pt5*circ/pi*(pi-atan2(xy(2,il,jl),-(xy(1,il,jl)-pt5)))
! field = pt5*circ/pi*(pi-atan2(xy(2,il,jl),-(xy(1,il,jl)-pt5)))

  if (jl .eq. 1) then
    if (il.ge.1 .and. il.le.na) then
      field = xy(1,il,jl) + pt5*circ/pi*(pi-atan2(xy(2,il,jl), &
            -(xy(1,il,jl)-pt5))+two*pi)
!     field = pt5*circ/pi*(pi-atan2(xy(2,il,jl),-(xy(1,il,jl)-pt5))+two*pi)
    end if
  end if

end function field
  
!============================================================================!
        subroutine initial
!============================================================================!
        use global
        implicit none

        real :: xil, etal, phiu, phil
        integer :: iu, il

        real, external :: field
!============================================================================!

!.... The conformal mapping for the parabolic cylinder is given by

!....    x = 1/2 * ( xi^2 - eta^2 ) + 1/2
!....    y = xi * eta

        if (restart .eq. 0) then             ! uniform flow in the +x direction
          !$omp parallel do private(i)
          do j = 1, ny
            do i = 1, nx
              phi(i,j) = field(i,j)
            end do
          end do
          j = 1
          do i = 1, na
            iu = nx - i + 1 
            phil = field(i,j)
            phiu = field(iu,j)
            write(55,"(5(1pe13.6,1x))") xy(1,i,1), phil, phiu, phiu-phil
          end do
          !call flush(55)
        else if (restart .eq. 1) then        ! restart from a previous solution
          open(20,file='restart.dat',form='unformatted',status='old',err=10)
          read(20) phi
          close(20)
        else if (restart .eq. 2) then        ! attempt to add mach correction
          beta = sqrt(one - Ma**2)
          !$omp parallel do private(i,etal,xil,u,v,t,rho)
          do j = 1, ny
            do i = 1, nx
              etal = sqrt(pt5 - xy(1,i,j) + pt5*sqrt((two*xy(1,i,j)-one)**2 + &
                     four * beta**2 * xy(2,i,j)**2))
              xil = beta * xy(2,i,j) / etal
              phi(i,j) = xy(1,i,j) + (pt5*(xil**2-etal**2 )+etal - &
                         xy(1,i,j))/beta**2
              u = one + ((etal**2 - etal + xil**2) / &
                  (xil**2 + etal**2) - one) / beta**2
              v = xil / (xil**2 + etal**2) / beta
              t = one - pt5*gamma1*Ma**2*( u**2 + v**2 - one )
              rho = t**(one/gamma1)
            end do
          end do
        else if (restart .eq. 3) then        ! works for pcyl
          !$omp parallel do private(i,etal,xil,u,v,t,rho)
          do j = 1, ny
            do i = 1, nx
              etal = sqrt(pt5-xy(1,i,j)+pt5*sqrt((two*xy(1,i,j)-one)**2 + &
                     four*xy(2,i,j)**2))
              xil = xy(2,i,j) / etal
              phi(i,j) = pt5 * ( xil**2 - etal**2 ) + etal
              phis(i,j) = phi(i,j)
              u = (etal**2 - etal + xil**2) / (xil**2 + etal**2)
              v = xil / (xil**2 + etal**2)
              t = one - pt5*gamma1*Ma**2*( u**2 + v**2 - one )
              rho = t**(one/gamma1)
            end do
          end do
        else if (restart .eq. 4) then
          !$omp parallel do private(i,etal,xil,u,v,t,rho)
          do j = 1, ny
            do i = 1, nx
              phi(i,j) = xy(1,i,j) + pt5 * log( xy(1,i,j)**2 + xy(2,i,j)**2 )
            end do
          end do
        end if

        return
10      call error('initial$','Unable to open restart file.$')
        end
!============================================================================!
        subroutine input
!============================================================================!
        use global
        implicit none
!============================================================================!
        write(*,"('Enter Ma ==> ',$)")
        read(*,*) Ma
        write(*,"('Enter sigma, omega ==> ',$)")
        read(*,*) sigma, omega
        write(*,"('Enter niter ==> ',$)")
        read(*,*) niter
        write(*,"('Enter restart ==> ',$)")
        read(*,*) restart
        write(*,"('Enter sweep angle ==> ',$)")
        read(*,*) lambda
        lambda = lambda * pi / 180.0
        write(*,"('Enter ispg, As, xs ==> ',$)") 
        read(*,*) ispg, As, xs
        write(*,"('Enter eps_e ==> ',$)")
        read(*,*) eps_e
!       write(*,"('Enter loctime, cflmax ==> ',$)")
!       read(*,*) loctime, cflmax

!.... setup boundary condition flags

!       left   = 0      ! symmetry
!       right  = 1      ! Reimann
!       right  = 0      ! Hard incompressible
!       bottom = 0      ! wall
!       top    = 1      ! Reimann
!       top    = 0      ! Hard incompressible

        write(*,"('Enter left, right, bottom, top BC flags ==> ',$)")
        read(*,*) left, right, bottom, top
        write(*,"('Enter xper, yper ==> ',$)")
        read(*,*) xper, yper
        write(*,"('Enter lsym, rsym, bsym, tsym ==> ',$)")
        read(*,*) lsym, rsym, bsym, tsym
        write(*,"('Enter carp ==> ',$)")
        read(*,*) carp
        write(*,*)
!       read(*,*) wakecut
!       write(*,*)

!.... get airfoil starting and stopping node for c-grid case

        if (wakecut) then
          write(*,"('Enter na, nb, circ==> ',$)")
          read(*,*) na, nb, circ
        end if
        write(*,*)

!.... turn off boundary conditions if periodic

        if (xper) then
          left  = -1
          right = -1
          lsym  = .false.
          rsym  = .false.
        end if

        if (yper) then
          top = -1
          bottom = -1
          bsym   = .false.
          tsym   = .false.
        end if

!.... check for symmetries

        if (bsym) bottom = -1
        if (tsym) top    = -1
        if (lsym) left   = -1
        if (rsym) right  = -1

        return
        end
!============================================================================!
        subroutine itrbc( )
!============================================================================!
        use global
        use stencil
        implicit none

!.... Riemann boundary variables

        real, allocatable :: etab(:), xib(:), ub(:), vb(:), cb(:)
        real, allocatable :: bn1(:), bn2(:), bn(:), vn(:)
        real, allocatable :: rhob(:), tb(:), pb(:), phib(:)

        integer :: ib
        real, external :: field
!============================================================================!

!.... top-bottom periodic boundary condition

        if (yper) then
          phi(:,ny) = phi(:,1)
        end if

!.... hard boundary condition on top side

        if (top.eq.0) then
          if (restart .eq. 3) then
            allocate( etab(nx), xib(nx) )
            etab = sqrt(pt5 - xy(1,:,ny) + &
                   pt5*sqrt((two*xy(1,:,ny)-one)**2 + four * xy(2,:,ny)**2))
            xib = xy(2,:,ny) / etab
            phi(1:bx,ny) = pt5 * ( xib(1:bx)**2 - etab(1:bx)**2 ) + &
                           etab(1:bx)
            deallocate( etab, xib )
          else if (restart.eq.4) then
            phi(1:bx,ny) = xy(1,1:bx,ny) + pt5 * log( xy(1,1:bx,ny)**2 + &
                           xy(2,1:bx,ny)**2 )
          else 
            do i = 1, bx
              phi(i,ny) = field(i,ny)
            end do
          end if
        end if

!.... Reimann on top boundary

!!$     if (top.eq.1) then
!!$       call grad(ndof, nx, ny, phi, g1phi, g2phi, dxi, deta, optx, opty, &
!!$                 xper, yper, lsym, rsym, bsym, tsym, carp)
!!$
!!$       u   = m1 * g1phi + n1 * g2phi 
!!$       v   = m2 * g1phi + n2 * g2phi
!!$       t   = one + gamma1 * Ma**2 * pt5 * ( one - u**2 - v**2 )
!!$       c   = sqrt(t) / Ma
!!$       rho = t ** ( one / gamma1 )
!!$       p   = rho * t / (gamma * Ma**2) 
!!$
!!$       allocate( bn(nx), bn1(nx), bn2(nx), uint(nx), vint(nx), cint(nx) )
!!$       allocate( etab(nx), xib(nx), ub(nx), vb(nx), cb(nx), phib(nx) )
!!$       etab = sqrt(pt5 - xy(1,:,ny) + pt5*sqrt((two*xy(1,:,ny)-one)**2 + &
!!$              four * xy(2,:,ny)**2))
!!$       xib  = xy(2,:,ny) / etab
!!$       ub   = (etab**2 - etab + xib**2) / (xib**2 + etab**2)
!!$       vb   = xib / (xib**2 + etab**2)
!!$       cb   = sqrt(one - pt5*gamma1*Ma**2*( ub**2 + vb**2 - one )) / Ma
!!$
!!$       bn(:)  = one / sqrt( n1(:,ny)**2 + n2(:,ny)**2 )
!!$       bn1(:) = n1(:,ny) * bn
!!$       bn2(:) = n2(:,ny) * bn
!!$
!!$       uint = two * u(:,ny-1) - u(:,ny-2)
!!$       vint = two * v(:,ny-1) - v(:,ny-2)
!!$       cint = two * c(:,ny-1) - c(:,ny-2)
!!$       phib = ( pt5 * deta * bn * &
!!$              ( bn1 * ub + bn2 * vb - two * cb / gamma1 + &
!!$                bn1 * uint + bn2 * vint + two * cint / gamma1 ) + &
!!$                gc2 * phi(:,ny-1) + gc3 * phi(:,ny-2) + &
!!$                gc4 * phi(:,ny-3) + gc5 * phi(:,ny-4) ) / (-gc1)
!!$       phi(1:bx,ny) = phib(1:bx)
!!$       deallocate( etab, xib, ub, vb, cb, phib )
!!$       deallocate( bn, bn1, bn2, uint, vint, cint )
!!$     end if

!.... bottom boundary for inviscid wall

        j = 1
        if (wakecut) then

           call grad(ndof, nx, ny, phi, gphi, dxi, deta, optx, opty, &
                 xper, yper, lsym, rsym, bsym, tsym, carp)

!!$            do i = 1, na
!!$           ib = nx - i + 1
!!$           phi(i,1) = ( -m(4,i,1)/deta*(gc2 * phi(i,2) + gc3 * phi(i,3) + &
!!$                                         gc4 * phi(i,4) + gc5 * phi(i,5) ) + &
!!$                           m(4,ib,1)/deta * ( gc1 * (-circ) + &
!!$                                         gc2 * phi(ib,2) + gc3 * phi(ib,3) + &
!!$                                         gc4 * phi(ib,4) + gc5 * phi(ib,5))&
!!$                   +(-m(2,i,1)*gphi(1,i,1) + m(2,ib,1)*gphi(1,ib,1))  &
!!$                   )/(m(4,i,1)/deta*gc1 - m(4,ib,1)/deta*gc1)
!!$         end do
        
!!$            do i = 1, na
!!$           ib = nx - i + 1
!!$           phi(i,1) = ( -m(4,i,1)/deta*(gk2 * phi(i,2) + gk3 * phi(i,3)) + &
!!$                           m(4,ib,1)/deta * ( gk1 * (-circ) + &
!!$                                         gk2 * phi(ib,2) + gk3 * phi(ib,3) )&
!!$                   +(-m(2,i,1)*gphi(1,i,1) + m(2,ib,1)*gphi(1,ib,1))  &
!!$                   )/(m(4,i,1)/deta*gk1 - m(4,ib,1)/deta*gk1)
!!$         end do
!!$
            do i = 1, na
              ib = nx - i + 1
              phi(i,1) = ( -m(4,i,1) * ( gc2 * phi(i,2) + gc3 * phi(i,3) + &
                                         gc4 * phi(i,4) + gc5 * phi(i,5) ) + &
                           m(4,ib,1) * ( gc1 * (-circ) + &
                                         gc2 * phi(ib,2) + gc3 * phi(ib,3) + &
                                         gc4 * phi(ib,4) + gc5 * phi(ib,5))&
                   +(-m(2,i,1)*gphi(1,i,1) + m(2,ib,1)*gphi(1,ib,1))*deta   &
                   )/(m(4,i,1)*gc1 - m(4,ib,1)*gc1)
            end do

!!$
!!$         phi(na+1:nb-1,1) = -( gk2 * phi(na+1:nb-1,2) + &
!!$                               gk3 * phi(na+1:nb-1,3) ) / gk1

            phi(na+1:nb-1,1) = -( gc2 * phi(na+1:nb-1,2) + &
                                  gc3 * phi(na+1:nb-1,3) + &
                                  gc4 * phi(na+1:nb-1,4) + &
                                  gc5 * phi(na+1:nb-1,5) ) / gc1

            do i = nb, nx
              phi(i,1) = phi(na-(i-nb),1) - circ
            end do

         else
          if (bottom.eq.0) then
            phi(1:bx,1) = -( gc2 * phi(1:bx,2) + &
                             gc3 * phi(1:bx,3) + &
                             gc4 * phi(1:bx,4) + &
                             gc5 * phi(1:bx,5) ) / gc1
          end if
        end if

!.... left-right periodic boundary condition

        if (xper) then
          phi(nx,:) = phi(1,:)
        end if

!.... hard boundary condition on left side

        if (left.eq.0) then
          do j = 1, by
            phi(1,j) = field(1,j)
          end do
        end if

!.... Extrapolation of left boundary

        if (left.eq.2) then
          phi(1,1:by) = two * phi(2,1:by) - phi(3,1:by)
        end if

!.... hacked wake test

        if (right.eq.-2) then
          do j = 1, ny
            phi(nx,j) = phi(1,j)
          end do
        end if

!.... hard boundary condition on right side

        if (right.eq.0) then
          if (restart .eq. 3) then
            allocate( etab(ny), xib(ny) )
            etab = sqrt(pt5 - xy(1,nx,:) + pt5*sqrt((two*xy(1,nx,:)-one)**2 + &
                   four * xy(2,nx,:)**2))
            xib = xy(2,nx,:) / etab
            phi(nx,1:by) = pt5 * ( xib(1:by)**2 - etab(1:by)**2 ) + &
                           etab(1:by)
            deallocate( etab, xib )
          else if (restart.eq.4) then
            phi(nx,1:by) = xy(1,nx,1:by) + pt5 * log( xy(1,nx,1:by)**2 + &
                           xy(2,nx,1:by)**2 )
          else
            do j = 1, by
              phi(nx,j) = field(nx,j)
            end do
          end if
        end if

!.... Reimann on right boundary

!!$     if (right.eq.1) then
!!$       call grad(ndof, nx, ny, phi, g1phi, g2phi, dxi, deta, optx, opty, &
!!$                 xper, yper, lsym, rsym, bsym, tsym, carp)
!!$
!!$       u   = m1 * g1phi + n1 * g2phi 
!!$       v   = m2 * g1phi + n2 * g2phi
!!$       t   = one + gamma1 * Ma**2 * pt5 * ( one - u**2 - v**2 )
!!$       c   = sqrt(t) / Ma
!!$       rho = t ** ( one / gamma1 )
!!$       p   = rho * t / (gamma * Ma**2)
!!$
!!$       allocate( bn(ny), bn1(ny), bn2(ny), uint(ny), vint(ny), cint(ny) )
!!$       allocate( etab(ny), xib(ny), ub(ny), vb(ny), cb(ny), phib(ny) )
!!$       etab = sqrt(pt5 - xy(1,nx,:) + pt5*sqrt((two*xy(1,nx,:)-one)**2 + &
!!$              four * xy(2,nx,:)**2))
!!$       xib  = xy(2,nx,:) / etab
!!$       ub   = (etab**2 - etab + xib**2) / (xib**2 + etab**2)
!!$       vb   = xib / (xib**2 + etab**2)
!!$       cb   = sqrt(one - pt5*gamma1*Ma**2*( ub**2 + vb**2 - one )) / Ma
!!$
!!$       bn(:)  = one / sqrt( m1(nx,:)**2 + m2(nx,:)**2 )
!!$       bn1(:) = m1(nx,:) * bn
!!$       bn2(:) = m2(nx,:) * bn
!!$       uint = two * u(nx-1,:) - u(nx-2,:)
!!$       vint = two * v(nx-1,:) - v(nx-2,:)
!!$       cint = two * c(nx-1,:) - c(nx-2,:)
!!$       phib = ( pt5 * dxi * bn * &
!!$              ( bn1 * ub + bn2 * vb - two * cb / gamma1 + &
!!$                bn1 * uint + bn2 * vint + two * cint / gamma1 ) + &
!!$                gc2 * phi(nx-1,:) + gc3 * phi(nx-2,:) + &
!!$                gc4 * phi(nx-3,:) + gc5 * phi(nx-4,:) ) / (-gc1)
!!$       phi(nx,1:by) = phib(1:by)
!!$       deallocate( etab, xib, ub, vb, cb, phib )
!!$       deallocate( bn, bn1, bn2, uint, vint, cint)
!!$     end if

!.... Extrapolation of right boundary

        if (right.eq.2) then
          phi(nx,1:by) = two * phi(nx-1,1:by) - phi(nx-2,1:by)
        end if

        return
        end
!============================================================================!
        subroutine lhs1
!============================================================================!
        use global
        use stencil
        implicit none

        real :: a1, a2, a3, a4, a5
        real :: b1, b2, b3, b4, b5
!============================================================================!

!.... fourth-order first-derivative stencil

        a1 = ga1  * dxiinv
        a2 = ga2  * dxiinv
        a3 = zero * dxiinv
        a4 = ga3  * dxiinv
        a5 = ga4  * dxiinv

!.... fourth-order second-derivative stencil

        b1 = da1 * dxiinv**2
        b2 = da2 * dxiinv**2
        b3 = da3 * dxiinv**2
        b4 = da4 * dxiinv**2
        b5 = da5 * dxiinv**2

!.... first LHS interior

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            mat(1,i,j) = a1 * A(3,i,j) + b1 * A(1,i,j)
            mat(2,i,j) = a2 * A(3,i,j) + b2 * A(1,i,j)
            mat(3,i,j) = a3 * A(3,i,j) + b3 * A(1,i,j)
            mat(4,i,j) = a4 * A(3,i,j) + b4 * A(1,i,j)
            mat(5,i,j) = a5 * A(3,i,j) + b5 * A(1,i,j)
          end do
        end do

!.... implicit damping term

        if (eps_e.ne.zero) then
!$omp parallel do private(i,j)
          do j = 1, ny
            do i = 1, nx
              mat(1,i,j) = mat(1,i,j) - eps_e * fb1
              mat(2,i,j) = mat(2,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(4,i,j) = mat(4,i,j) - eps_e * fb4
              mat(5,i,j) = mat(5,i,j) - eps_e * fb5
            end do
          end do
        end if

        if (.not. xper) then

!.... left boundary nodes

        if (lsym) then
!$omp parallel do private(i,j)
          do j = 1, ny
            i = 1
            mat(1,i,j) = zero
            mat(2,i,j) = zero
            mat(3,i,j) =      a3 * A(3,i,j) +      b3 * A(1,i,j)
            mat(4,i,j) = (a4+a2) * A(3,i,j) + (b4+b2) * A(1,i,j)
            mat(5,i,j) = (a5+a1) * A(3,i,j) + (b5+b1) * A(1,i,j)
            
            if (eps_e.ne.zero) then
              mat(5,i,j) = mat(5,i,j) - eps_e * fb1
              mat(4,i,j) = mat(4,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(4,i,j) = mat(4,i,j) - eps_e * fb4
              mat(5,i,j) = mat(5,i,j) - eps_e * fb5
            end if
            
            i = 2
            mat(1,i,j) = zero
            mat(2,i,j) =      a2 * A(3,i,j) +      b2 * A(1,i,j)
            mat(3,i,j) = (a3+a1) * A(3,i,j) + (b3+b1) * A(1,i,j)
            mat(4,i,j) =      a4 * A(3,i,j) +      b4 * A(1,i,j)
            mat(5,i,j) =      a5 * A(3,i,j) +      b5 * A(1,i,j)
            
            if (eps_e.ne.zero) then
              mat(3,i,j) = mat(3,i,j) - eps_e * fb1
              mat(2,i,j) = mat(2,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(4,i,j) = mat(4,i,j) - eps_e * fb4
              mat(5,i,j) = mat(5,i,j) - eps_e * fb5
            end if
          end do
        else
!$omp parallel do private(i,j)
          do j = 1, ny
            i = 1
            mat(3,i,j) = gc1 * dxiinv * A(3,i,j) + dd1 * dxiinv**2 * A(1,i,j) 
            mat(4,i,j) = gc2 * dxiinv * A(3,i,j) + dd2 * dxiinv**2 * A(1,i,j)
            mat(5,i,j) = gc3 * dxiinv * A(3,i,j) + dd3 * dxiinv**2 * A(1,i,j)
            mat(1,i,j) = gc4 * dxiinv * A(3,i,j) + dd4 * dxiinv**2 * A(1,i,j)
            mat(2,i,j) = gc5 * dxiinv * A(3,i,j) + dd5 * dxiinv**2 * A(1,i,j)
            
            i = 2
            mat(2,i,j) = gb1 * dxiinv * A(3,i,j) + db1 * dxiinv**2 * A(1,i,j)
            mat(3,i,j) = gb2 * dxiinv * A(3,i,j) + db2 * dxiinv**2 * A(1,i,j)
            mat(4,i,j) = gb3 * dxiinv * A(3,i,j) + db3 * dxiinv**2 * A(1,i,j)
            mat(5,i,j) = gb4 * dxiinv * A(3,i,j) + db4 * dxiinv**2 * A(1,i,j)
            mat(1,i,j) = gb5 * dxiinv * A(3,i,j) + db5 * dxiinv**2 * A(1,i,j)
            
            if (eps_e.ne.zero) then
              mat(2,i,j) = mat(2,i,j) - eps_e * (-one)
              mat(3,i,j) = mat(3,i,j) - eps_e * (two)
              mat(4,i,j) = mat(4,i,j) - eps_e * (-one)
            end if
          end do
        end if

!.... right boundary nodes

        if (rsym) then
!$omp parallel do private(i,j)
          do j = 1, ny
            i = nx-1
            mat(1,i,j) = a1 * A(3,i,j) + b1 * A(1,i,j)
            mat(2,i,j) = a2 * A(3,i,j) + b2 * A(1,i,j)
            mat(3,i,j) = (a3+a5) * A(3,i,j) + (b3+b5) * A(1,i,j)
            mat(4,i,j) = a4 * A(3,i,j) + b4 * A(1,i,j)
            mat(5,i,j) = zero

            if (eps_e.ne.zero) then
              mat(1,i,j) = mat(1,i,j) - eps_e * fb1
              mat(2,i,j) = mat(2,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(4,i,j) = mat(4,i,j) - eps_e * fb4
              mat(3,i,j) = mat(3,i,j) - eps_e * fb5
            end if

            i = nx
            mat(1,i,j) = (a1+a5) * A(3,i,j) + (b1+b5) * A(1,i,j)
            mat(2,i,j) = (a2+a4) * A(3,i,j) + (b2+b4) * A(1,i,j)
            mat(3,i,j) = a3 * A(3,i,j) + b3 * A(1,i,j)
            mat(4,i,j) = zero
            mat(5,i,j) = zero

            if (eps_e.ne.zero) then
              mat(1,i,j) = mat(1,i,j) - eps_e * fb1
              mat(2,i,j) = mat(2,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(2,i,j) = mat(2,i,j) - eps_e * fb4
              mat(1,i,j) = mat(1,i,j) - eps_e * fb5
            end if
          end do
        else
!$omp parallel do private(i,j)
          do j = 1, ny
            i = nx-1
            mat(5,i,j) = -gb5 * dxiinv * A(3,i,j) + db5 * dxiinv**2 * A(1,i,j)
            mat(1,i,j) = -gb4 * dxiinv * A(3,i,j) + db4 * dxiinv**2 * A(1,i,j)
            mat(2,i,j) = -gb3 * dxiinv * A(3,i,j) + db3 * dxiinv**2 * A(1,i,j)
            mat(3,i,j) = -gb2 * dxiinv * A(3,i,j) + db2 * dxiinv**2 * A(1,i,j)
            mat(4,i,j) = -gb1 * dxiinv * A(3,i,j) + db1 * dxiinv**2 * A(1,i,j)
            
            if (eps_e.ne.zero) then
              mat(2,i,j) = mat(2,i,j) - eps_e * (-one)
              mat(3,i,j) = mat(3,i,j) - eps_e * (two)
              mat(4,i,j) = mat(4,i,j) - eps_e * (-one)
            end if
            
            i = nx
            mat(4,i,j) = -gc5 * dxiinv * A(3,i,j) + dd5 * dxiinv**2 * A(1,i,j) 
            mat(5,i,j) = -gc4 * dxiinv * A(3,i,j) + dd4 * dxiinv**2 * A(1,i,j)
            mat(1,i,j) = -gc3 * dxiinv * A(3,i,j) + dd3 * dxiinv**2 * A(1,i,j)
            mat(2,i,j) = -gc2 * dxiinv * A(3,i,j) + dd2 * dxiinv**2 * A(1,i,j)
            mat(3,i,j) = -gc1 * dxiinv * A(3,i,j) + dd1 * dxiinv**2 * A(1,i,j)
          end do
        end if  ! rsym

        end if  ! xper

!.... wakecut

!!$        if (wakecut) then
!!$          j = 1                        !.... left side
!!$       i = na-1
!!$       mat(5,i,j) = zero
!!$       mat(1,i,j) = -gl4 * dxiinv * A(3,i,j) + dl4 * dxiinv**2 * A(1,i,j)
!!$       mat(2,i,j) = -gl3 * dxiinv * A(3,i,j) + dl3 * dxiinv**2 * A(1,i,j)
!!$       mat(3,i,j) = -gl2 * dxiinv * A(3,i,j) + dl2 * dxiinv**2 * A(1,i,j)
!!$       mat(4,i,j) = -gl1 * dxiinv * A(3,i,j) + dl1 * dxiinv**2 * A(1,i,j)
!!$
!!$       if (eps_e.ne.zero) then
!!$         mat(2,i,j) = mat(2,i,j) - eps_e * (-one)
!!$         mat(3,i,j) = mat(3,i,j) - eps_e * (two)
!!$         mat(4,i,j) = mat(4,i,j) - eps_e * (-one)
!!$       end if
!!$
!!$       i = na
!!$       mat(4,i,j) = zero
!!$       mat(5,i,j) = zero
!!$       mat(1,i,j) = -gk3 * dxiinv * A(3,i,j) + dk3 * dxiinv**2 * A(1,i,j)
!!$       mat(2,i,j) = -gk2 * dxiinv * A(3,i,j) + dk2 * dxiinv**2 * A(1,i,j)
!!$       mat(3,i,j) = -gk1 * dxiinv * A(3,i,j) + dk1 * dxiinv**2 * A(1,i,j)
!!$       
!!$
!!$       i = nb                       !.... right side
!!$       mat(3,i,j) = gk1 * dxiinv * A(3,i,j) + dk1 * dxiinv**2 * A(1,i,j) 
!!$       mat(4,i,j) = gk2 * dxiinv * A(3,i,j) + dk2 * dxiinv**2 * A(1,i,j)
!!$       mat(5,i,j) = gk3 * dxiinv * A(3,i,j) + dk3 * dxiinv**2 * A(1,i,j)
!!$       mat(1,i,j) = zero
!!$       mat(2,i,j) = zero
!!$
!!$       i = nb+1
!!$       mat(2,i,j) = gl1 * dxiinv * A(3,i,j) + dl1 * dxiinv**2 * A(1,i,j)
!!$       mat(3,i,j) = gl2 * dxiinv * A(3,i,j) + dl2 * dxiinv**2 * A(1,i,j)
!!$       mat(4,i,j) = gl3 * dxiinv * A(3,i,j) + dl3 * dxiinv**2 * A(1,i,j)
!!$       mat(5,i,j) = gl4 * dxiinv * A(3,i,j) + dl4 * dxiinv**2 * A(1,i,j)
!!$       mat(1,i,j) = zero
!!$
!!$       if (eps_e.ne.zero) then
!!$         mat(2,i,j) = mat(2,i,j) - eps_e * (-one)
!!$         mat(3,i,j) = mat(3,i,j) - eps_e * (two)
!!$         mat(4,i,j) = mat(4,i,j) - eps_e * (-one)
!!$       end if
!!$        end if

!.... sponge

        if (ispg.ne.0) then
!$omp parallel do private(i,j)
          do j = 1, ny
            do i = 1, nx
              mat(3,i,j) = mat(3,i,j) - spg(i,j)
            end do
          end do
        end if

!.... put in the time term

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            mat(1,i,j) = -sigma * dtl(i,j) * mat(1,i,j)
            mat(2,i,j) = -sigma * dtl(i,j) * mat(2,i,j)
            mat(3,i,j) =  one - sigma * dtl(i,j) * mat(3,i,j)
            mat(4,i,j) = -sigma * dtl(i,j) * mat(4,i,j)
            mat(5,i,j) = -sigma * dtl(i,j) * mat(5,i,j)
          end do
        end do

!.... left boundary condition

        if (left.eq.0) then
!$omp parallel do private(i,j)
          do j = 1, by
            mat(:,1,j) = zero
            mat(3,1,j) = -one
          end do
        else if (left.eq.2) then
!$omp parallel do private(i,j)
          do j = 1, by
            mat(:,1,j) =  zero
            mat(5,1,j) = -one
            mat(4,1,j) =  two
            mat(3,1,j) = -one
          end do
        else if (left.ne.-1) then
          call error('lhs1$', 'Non supported left BC flag$')
        end if
          
!.... right boundary condition

        if (right.eq.0) then
!$omp parallel do private(i,j)
          do j = 1, by
            mat(:,nx,j) = zero
            mat(3,nx,j) = -one
          end do
        else if (right.eq.1) then
!$omp parallel do private(i,j)
          do j = 1, by
            mat(:,nx,j) = zero
            mat(4,nx,j) = -gc5
            mat(5,nx,j) = -gc4
            mat(1,nx,j) = -gc3
            mat(2,nx,j) = -gc2
            mat(3,nx,j) = -gc1
          end do
        else if (right.eq.2) then
!$omp parallel do private(i,j)
          do j = 1, by
            mat(:,nx,j) =  zero
            mat(1,nx,j) = -one
            mat(2,nx,j) =  two
            mat(3,nx,j) = -one
          end do
        else if (right.eq.-2) then

        else if (right.ne.-1) then
          call error('lhs1$', 'Non supported right BC flag$')
        end if
        
!.... bottom boundary condition

        if (wakecut) then
          mat(:,1:na,1) = zero
          mat(3,1:na,1) = one

          mat(:,na+1:nb-1,1) = zero
          mat(3,na+1:nb-1,1) = one

          mat(:,nb:nx,1) = zero
          mat(3,nb:nx,1) = one
        else
          if (bottom.eq.0) then
            mat(:,1:bx,1) = zero
            mat(3,1:bx,1) = one
          else if (bottom.ne.-1) then
            call error('lhs1$', 'Non supported bottom BC flag$')
          end if
        end if

!.... top boundary condition

        if (top.eq.0 .or. top.eq.1) then
          mat(:,1:bx,ny) = zero
          mat(3,1:bx,ny) = one
        else if (top.ne.-1) then
          call error('lhs1$', 'Non supported top BC flag$')
        end if

        return
        end
!============================================================================!
        subroutine lhs2
!============================================================================!
        use global
        use stencil
        implicit none

        real :: a1, a2, a3, a4, a5
        real :: b1, b2, b3, b4, b5

        integer :: ib
!============================================================================!

!.... fourth-order first-derivative stencil

        a1 = ga1  * detainv
        a2 = ga2  * detainv
        a3 = zero * detainv
        a4 = ga3  * detainv
        a5 = ga4  * detainv

!.... fourth-order second-derivative stencil

        b1 = da1 * detainv**2
        b2 = da2 * detainv**2
        b3 = da3 * detainv**2
        b4 = da4 * detainv**2
        b5 = da5 * detainv**2

!.... second LHS interior

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            mat(1,i,j) = a1 * A(4,i,j) + b1 * A(2,i,j)
            mat(2,i,j) = a2 * A(4,i,j) + b2 * A(2,i,j)
            mat(3,i,j) = a3 * A(4,i,j) + b3 * A(2,i,j)
            mat(4,i,j) = a4 * A(4,i,j) + b4 * A(2,i,j)
            mat(5,i,j) = a5 * A(4,i,j) + b5 * A(2,i,j)
          end do
        end do

!.... implicit damping term

        if (eps_e.ne.zero) then
!$omp parallel do private(i,j)
          do j = 1, ny
            do i = 1, nx
              mat(1,i,j) = mat(1,i,j) - eps_e * fb1
              mat(2,i,j) = mat(2,i,j) - eps_e * fb2
              mat(3,i,j) = mat(3,i,j) - eps_e * fb3
              mat(4,i,j) = mat(4,i,j) - eps_e * fb4
              mat(5,i,j) = mat(5,i,j) - eps_e * fb5
            end do
          end do
        end if

        if (.not. yper) then

!.... bottom boundary nodes
        
        if (bsym) then
          mat(1,:,1) = zero
          mat(2,:,1) = zero
          mat(3,:,1) =      a3 * A(4,:,1) +      b3 * A(2,:,1)
          mat(4,:,1) = (a4+a2) * A(4,:,1) + (b4+b2) * A(2,:,1)
          mat(5,:,1) = (a5+a1) * A(4,:,1) + (b5+b1) * A(2,:,1)

          if (eps_e.ne.zero) then
            mat(5,:,1) = mat(5,:,1) - eps_e * fb1
            mat(4,:,1) = mat(4,:,1) - eps_e * fb2
            mat(3,:,1) = mat(3,:,1) - eps_e * fb3
            mat(4,:,1) = mat(4,:,1) - eps_e * fb4
            mat(5,:,1) = mat(5,:,1) - eps_e * fb5
          end if

          mat(1,:,2) = zero
          mat(2,:,2) =      a2 * A(4,:,2) +      b2 * A(2,:,2)
          mat(3,:,2) = (a3+a1) * A(4,:,2) + (b3+b1) * A(2,:,2)
          mat(4,:,2) =      a4 * A(4,:,2) +      b4 * A(2,:,2)
          mat(5,:,2) =      a5 * A(4,:,2) +      b5 * A(2,:,2)

          if (eps_e.ne.zero) then
            mat(3,:,2) = mat(3,:,2) - eps_e * fb1
            mat(2,:,2) = mat(2,:,2) - eps_e * fb2
            mat(3,:,2) = mat(3,:,2) - eps_e * fb3
            mat(4,:,2) = mat(4,:,2) - eps_e * fb4
            mat(5,:,2) = mat(5,:,2) - eps_e * fb5
          end if
        else if (wakecut) then

!.... left side of wake cut

          j = 1
          mat(3,1:na,j) = gk1 * detainv * A(4,1:na,j) + dk1 * detainv**2 * A(2,1:na,j) 
          mat(4,1:na,j) = gk2 * detainv * A(4,1:na,j) + dk2 * detainv**2 * A(2,1:na,j)
          mat(5,1:na,j) = gk3 * detainv * A(4,1:na,j) + dk3 * detainv**2 * A(2,1:na,j)
          mat(1,1:na,j) = zero
          mat(2,1:na,j) = zero

          j = 2
          mat(2,1:na,j) = gl1 * detainv * A(4,1:na,j) + dl1 * detainv**2 * A(2,1:na,j) 
          mat(3,1:na,j) = gl2 * detainv * A(4,1:na,j) + dl2 * detainv**2 * A(2,1:na,j)
          mat(4,1:na,j) = gl3 * detainv * A(4,1:na,j) + dl3 * detainv**2 * A(2,1:na,j)
          mat(5,1:na,j) = gl4 * detainv * A(4,1:na,j) + dl4 * detainv**2 * A(2,1:na,j)
          mat(1,1:na,j) = zero

          if (eps_e.ne.zero) then
            mat(2,1:na,j) = mat(2,1:na,j) - eps_e * (-one)
            mat(3,1:na,j) = mat(3,1:na,j) - eps_e * (two)
            mat(4,1:na,j) = mat(4,1:na,j) - eps_e * (-one)
          end if

!.... center of wake cut (body)

          j = 1
          mat(3,na+1:nb-1,j) = gc1 * detainv * A(4,na+1:nb-1,j) + dd1 * detainv**2 * A(2,na+1:nb-1,j) 
          mat(4,na+1:nb-1,j) = gc2 * detainv * A(4,na+1:nb-1,j) + dd2 * detainv**2 * A(2,na+1:nb-1,j)
          mat(5,na+1:nb-1,j) = gc3 * detainv * A(4,na+1:nb-1,j) + dd3 * detainv**2 * A(2,na+1:nb-1,j)
          mat(1,na+1:nb-1,j) = gc4 * detainv * A(4,na+1:nb-1,j) + dd4 * detainv**2 * A(2,na+1:nb-1,j)
          mat(2,na+1:nb-1,j) = gc5 * detainv * A(4,na+1:nb-1,j) + dd5 * detainv**2 * A(2,na+1:nb-1,j)

!!$       mat(3,na+1:nb-1,j) = gk1 * detainv * A(4,na+1:nb-1,j) + dk1 * detainv**2 * A(2,na+1:nb-1,j) 
!!$       mat(4,na+1:nb-1,j) = gk2 * detainv * A(4,na+1:nb-1,j) + dk2 * detainv**2 * A(2,na+1:nb-1,j)
!!$       mat(5,na+1:nb-1,j) = gk3 * detainv * A(4,na+1:nb-1,j) + dk3 * detainv**2 * A(2,na+1:nb-1,j)
!!$       mat(1,na+1:nb-1,j) = zero
!!$       mat(2,na+1:nb-1,j) = zero

          j = 2
          mat(2,na+1:nb-1,j) = gb1 * detainv * A(4,na+1:nb-1,j) + db1 * detainv**2 * A(2,na+1:nb-1,j) 
          mat(3,na+1:nb-1,j) = gb2 * detainv * A(4,na+1:nb-1,j) + db2 * detainv**2 * A(2,na+1:nb-1,j)
          mat(4,na+1:nb-1,j) = gb3 * detainv * A(4,na+1:nb-1,j) + db3 * detainv**2 * A(2,na+1:nb-1,j)
          mat(5,na+1:nb-1,j) = gb4 * detainv * A(4,na+1:nb-1,j) + db4 * detainv**2 * A(2,na+1:nb-1,j)
          mat(1,na+1:nb-1,j) = gb5 * detainv * A(4,na+1:nb-1,j) + db5 * detainv**2 * A(2,na+1:nb-1,j)

          if (eps_e.ne.zero) then
            mat(2,na+1:nb-1,j) = mat(2,na+1:nb-1,j) - eps_e * (-one)
            mat(3,na+1:nb-1,j) = mat(3,na+1:nb-1,j) - eps_e * (two)
            mat(4,na+1:nb-1,j) = mat(4,na+1:nb-1,j) - eps_e * (-one)
          end if

!.... right side of wake cut

          j = 1
          mat(3,nb:nx,j) = gk1 * detainv * A(4,nb:nx,j) + dk1 * detainv**2 * A(2,nb:nx,j) 
          mat(4,nb:nx,j) = gk2 * detainv * A(4,nb:nx,j) + dk2 * detainv**2 * A(2,nb:nx,j)
          mat(5,nb:nx,j) = gk3 * detainv * A(4,nb:nx,j) + dk3 * detainv**2 * A(2,nb:nx,j)
          mat(1,nb:nx,j) = zero
          mat(2,nb:nx,j) = zero

          j = 2
          mat(2,nb:nx,j) = gl1 * detainv * A(4,nb:nx,j) + dl1 * detainv**2 * A(2,nb:nx,j) 
          mat(3,nb:nx,j) = gl2 * detainv * A(4,nb:nx,j) + dl2 * detainv**2 * A(2,nb:nx,j)
          mat(4,nb:nx,j) = gl3 * detainv * A(4,nb:nx,j) + dl3 * detainv**2 * A(2,nb:nx,j)
          mat(5,nb:nx,j) = gl4 * detainv * A(4,nb:nx,j) + dl4 * detainv**2 * A(2,nb:nx,j)
          mat(1,nb:nx,j) = zero

          if (eps_e.ne.zero) then
            mat(2,nb:nx,j) = mat(2,nb:nx,j) - eps_e * (-one)
            mat(3,nb:nx,j) = mat(3,nb:nx,j) - eps_e * (two)
            mat(4,nb:nx,j) = mat(4,nb:nx,j) - eps_e * (-one)
          end if
        else
          j = 1
          mat(3,:,j) = gc1 * detainv * A(4,:,j) + dd1 * detainv**2 * A(2,:,j) 
          mat(4,:,j) = gc2 * detainv * A(4,:,j) + dd2 * detainv**2 * A(2,:,j)
          mat(5,:,j) = gc3 * detainv * A(4,:,j) + dd3 * detainv**2 * A(2,:,j)
          mat(1,:,j) = gc4 * detainv * A(4,:,j) + dd4 * detainv**2 * A(2,:,j)
          mat(2,:,j) = gc5 * detainv * A(4,:,j) + dd5 * detainv**2 * A(2,:,j)

          j = 2
          mat(2,:,j) = gb1 * detainv * A(4,:,j) + db1 * detainv**2 * A(2,:,j) 
          mat(3,:,j) = gb2 * detainv * A(4,:,j) + db2 * detainv**2 * A(2,:,j)
          mat(4,:,j) = gb3 * detainv * A(4,:,j) + db3 * detainv**2 * A(2,:,j)
          mat(5,:,j) = gb4 * detainv * A(4,:,j) + db4 * detainv**2 * A(2,:,j)
          mat(1,:,j) = gb5 * detainv * A(4,:,j) + db5 * detainv**2 * A(2,:,j)

          if (eps_e.ne.zero) then
            mat(2,:,j) = mat(2,:,j) - eps_e * (-one)
            mat(3,:,j) = mat(3,:,j) - eps_e * (two)
            mat(4,:,j) = mat(4,:,j) - eps_e * (-one)
          end if
        end if

!.... top boundary nodes

        if (tsym) then
          call error('lhs2$', 'tsym is not currently supported$')
        else
          mat(5,:,ny-1) = -gb5 * detainv * A(4,:,ny-1) + &
                           db5 * detainv**2 * A(2,:,ny-1) 
          mat(1,:,ny-1) = -gb4 * detainv * A(4,:,ny-1) + &
                           db4 * detainv**2 * A(2,:,ny-1)
          mat(2,:,ny-1) = -gb3 * detainv * A(4,:,ny-1) + &
                           db3 * detainv**2 * A(2,:,ny-1)
          mat(3,:,ny-1) = -gb2 * detainv * A(4,:,ny-1) + &
                           db2 * detainv**2 * A(2,:,ny-1)
          mat(4,:,ny-1) = -gb1 * detainv * A(4,:,ny-1) + &
                           db1 * detainv**2 * A(2,:,ny-1)

          if (eps_e.ne.zero) then
            mat(2,:,ny-1) = mat(2,:,ny-1) - eps_e * (-one)
            mat(3,:,ny-1) = mat(3,:,ny-1) - eps_e * (two)
            mat(4,:,ny-1) = mat(4,:,ny-1) - eps_e * (-one)
          end if

          mat(4,:,ny) = -gc5 * detainv * A(4,:,ny) + dd5 * detainv**2 * A(2,:,ny) 
          mat(5,:,ny) = -gc4 * detainv * A(4,:,ny) + dd4 * detainv**2 * A(2,:,ny)
          mat(1,:,ny) = -gc3 * detainv * A(4,:,ny) + dd3 * detainv**2 * A(2,:,ny)
          mat(2,:,ny) = -gc2 * detainv * A(4,:,ny) + dd2 * detainv**2 * A(2,:,ny)
          mat(3,:,ny) = -gc1 * detainv * A(4,:,ny) + dd1 * detainv**2 * A(2,:,ny)
        end if

        end if  ! yper

!.... put in time term

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            mat(1,i,j) = -sigma * dtl(i,j) * mat(1,i,j)
            mat(2,i,j) = -sigma * dtl(i,j) * mat(2,i,j)
            mat(3,i,j) =  one - sigma * dtl(i,j) * mat(3,i,j)
            mat(4,i,j) = -sigma * dtl(i,j) * mat(4,i,j)
            mat(5,i,j) = -sigma * dtl(i,j) * mat(5,i,j)
          end do
        end do
        
!.... left boundary condition

        if (left.eq.0 .or. left.eq.2) then
!$omp parallel do private(j)
          do j = 1, by
            mat(:,1,j) = zero
            mat(3,1,j) = one
          end do
        else if (left.ne.-1) then
          call error('lhs2$', 'Non supported left BC flag$')
        end if

!.... right boundary condition

        if (right.eq.0 .or. right.eq.1 .or. right.eq.2) then
!$omp parallel do private(j)
          do j = 1, by
            mat(:,nx,j) = zero
            mat(3,nx,j) = one
          end do
        else if (right.eq.-2) then

        else if (right.ne.-1) then
          call error('lhs2$', 'Non supported right BC flag$')
        end if
        
!.... top boundary condition

        if (top.eq.0) then
          mat(:,1:bx,ny) = zero
          mat(3,1:bx,ny) = -one
        else if (top.eq.1) then
          mat(:,1:bx,ny) = zero
          mat(4,1:bx,ny) = -gc5
          mat(5,1:bx,ny) = -gc4
          mat(1,1:bx,ny) = -gc3
          mat(2,1:bx,ny) = -gc2
          mat(3,1:bx,ny) = -gc1
        else if (top.ne.-1) then
          call error('lhs2$', 'Non supported top BC flag$')
        end if

!.... bottom boundary condition
        
        if (wakecut) then

!.... left portion (continuity of derivative)

          do i = 1, na
            ib = nx - i + 1
            mat(:,i,1) = zero

!!$            mat(1,i,1) =  m(4,ib,1)*gc2
!!$            mat(2,i,1) =  m(4,ib,1)*gc1
!!$            mat(3,i,1) = -m(4,i,1)*gc1
!!$            mat(4,i,1) = -m(4,i,1)*gc2
!!$            mat(5,i,1) = -m(4,i,1)*gc3

!!$            mat(1,i,1) =  m(4,ib,1)*gk2
!!$            mat(2,i,1) =  m(4,ib,1)*gk1
!!$            mat(3,i,1) = -m(4,i,1)*gk1
!!$            mat(4,i,1) = -m(4,i,1)*gk2
!!$            mat(5,i,1) = -m(4,i,1)*gk3

            mat(1,i,1) =  m(4,ib,1)
            mat(2,i,1) = -m(4,ib,1)
            mat(3,i,1) =  m(4,i,1)
            mat(4,i,1) = -m(4,i,1)
            mat(5,i,1) = zero
          end do

!.... center wall portion

          mat(:,na+1:nb-1,1) = zero
          mat(3,na+1:nb-1,1) = -gc1
          mat(4,na+1:nb-1,1) = -gc2
          mat(5,na+1:nb-1,1) = -gc3
          mat(1,na+1:nb-1,1) = -gc4
          mat(2,na+1:nb-1,1) = -gc5

!!$       mat(:,na+1:nb-1,1) = zero
!!$       mat(3,na+1:nb-1,1) = -gk1
!!$       mat(4,na+1:nb-1,1) = -gk2
!!$       mat(5,na+1:nb-1,1) = -gk3
!!$       mat(1,na+1:nb-1,1) = zero
!!$       mat(2,na+1:nb-1,1) = zero

!.... left portion (continuity or jump condition)

          mat(:,nb:nx,1) =  zero
          mat(3,nb:nx,1) = -one
          mat(2,nb:nx,1) =  one
        else          
          if (bottom.eq.0) then
            mat(:,1:bx,1) = zero
            mat(3,1:bx,1) = -gc1
            mat(4,1:bx,1) = -gc2
            mat(5,1:bx,1) = -gc3
            mat(1,1:bx,1) = -gc4
            mat(2,1:bx,1) = -gc5
!!$         mat(:,1:bx,1 = zero
!!$         mat(3,1:bx,1) = -gk1
!!$         mat(4,1:bx,1) = -gk2
!!$         mat(5,1:bx,1) = -gk3
!!$         mat(1,1:bx,1) = zero
!!$         mat(2,1:bx,1) = zero
          else if (bottom.ne.-1) then
            call error('lhs2$', 'Non supported bottom BC flag$')
          end if
        end if

        return
        end
!============================================================================!
        program npot
!============================================================================!
!  
!  Purpose:  Compressible potential flow solver in nonconservative form
!
!  Inputs:
!
!       Ma      => Freestream chordwise Mach number
!       sigma   => Pseudo time-step [0.1:1e5], try different value to
!                  speed convergence
!       omega   => Over-relaxation parameter (set equal to 1)
!       niter   => Number of iterations (I like 500 for each sigma)
!       restart => 0 = fresh start, 1 = restart
!       lambda  => Sweep angle (Only affects output)
!       ispg    => Sponge flag (not helpful:  set to 0)
!       As      => Sponge amplitude (set to 1)
!       xs      => Start of sponge (set to 0)
!       eps_e   => Smoother amplitude (set to 0)
!       left    => Left BC (recommend 0)
!       right   => Right BC (recommend 0)
!       bottom  => Bottom BC (recommend 0)
!       top     => Top BC (recommend 0)
!
!  Input Files:
!
!       grid.dat    => standard Plot3d grid-file
!       metric.dat  => LNS format metric file
!       restart.dat => Read if restart = 1
!
!  Output Files:
!
!       output.q  => Plot3d file for visualization
!       lns.dat     => LNS data-file format
!       *.pot       => Data for LNS potential flow boundary conditions
!
!  Notes:
!
!       There may be a better way of implementing the Riemann boudary
!       condition for the potential-flow equations.  See Shapiro: 
!       "The Dynamics and Thermodynamics of Compressible Fluid Flow, Vol. I"
!
!       The current hard (i.e. BC flag = 0) freestream boundary conditions
!       set the solution to the exact incompressible potential solution.
!       This doesn't work very well, so that the boundaries must be placed
!       very far away from the body (on the order of 1e8 nose radii).
!       I recommend an exponentially streched mesh (see confpc.f)
!
!  Author:   Scott Collis
!  
!  Date:     6-18-97
!
!  Revised:  10-12-00    Switched indices on lns.dat output file
!            10-12-00    Switched all indices
!            10-16-00    Corrected Penta solvers
!            10-18-00    Parallel version was tested and works for std
!                        boundary conditions -- need to implement
!                        periodic solvers
!            10-19-00    Changes metric data structures and gradients to 
!                        improve cache hits
!
!  Parallel environment:
!
!  OMP_NUM_THREADS #
!  OMP_SCHEDULE STATIC
!  OMP_DYNAMIC FALSE     OS cannot change number of threads 
!                        (This seems to lockup sometimes...?)
!  _DSM_MUSTRUN TRUE     Locks a thread to a CPU
!  _DSM_WAIT SPIN        Don't ever surrender a CPU
!
!  _DSM_MUSTRUN TRUE     This appears to be the important parameter!
!
!============================================================================!
        use global
        use stencil
        implicit none

!.... local variables

        real :: tmp
        real, allocatable :: mult(:), fact(:), per(:,:,:), per2(:,:)
!$sgi distribute mult(block), fact(block), per(*,*,block), per2(*,block)

        real, allocatable :: mat2(:,:,:), res2(:,:), mult2(:), fact2(:)
!$sgi distribute mat2(*,*,block), res2(*,block), mult2(block), fact2(block)

        real :: cpu, cpu1
        integer, parameter :: start = 0, end = 1
        logical :: metric_ji = .false.

        integer :: conserve=0
        real, allocatable :: res_uniform(:,:)

        integer :: blksize, numprocs, ia, ib

        real :: g1phit, g2phit, g11phit, g12phit, g22phit
        real :: gx1, gx2, gx3, gx4, gx5, gx6
        real :: gy1, gy2, gy3, gy4, gy5, gy6

        real, external :: field

        integer, external :: OMP_GET_NUM_THREADS
!============================================================================!

!.... initialize global variables (must do on SGI)

        ndof = 1; Ma = 0.1; gamma = 1.4; gamma1 = 0.4; cv = 716.5; 
        cp = 1003.1; Rgas = 286.6; Ns = 4; 
        optx=-1; opty=-1; xper=.false.; yper=.false.; 
        lsym=.false.; rsym=.false.; bsym=.false.; tsym=.false.; carp=.true.
        xs = 0.0; xt = 1.0;

!.... parse argument list

        narg = iargc()
        do iarg = 1, narg
          call getarg(iarg,arg)
          if (arg(1:1) .ne. '-') then
            nfile = nfile + 1
            if (nfile .gt. mfile) then
              write(*,*) '>> Error in argument list, too many file names'
                call exit(1)
           end if
            ifile(nfile) = iarg
          else
            select case (arg(1:3))
            case ('-wc')                ! for nonuniform bottom boundary
              wakecut = .true.
            case ('-nc') 
              carp = .false.
            case ('-ms') 
              metric_ji = .true.
            case ('-c1')
              conserve = 1
            case ('-c2')
              conserve = 2
            case ('-h')
              write(*,"('-----------------------------------------------')")
              write(*,"('Usage:  npot [options] < input.dat ')")
              write(*,"('-----------------------------------------------')")
              write(*,"('   -h:  this help')")
              write(*,"('-----------------------------------------------')")
              write(*,"('   -wc: for wake cut')")
              write(*,"('   -nc: for no carpenters')")
              write(*,"('   -ms: read metric file assuming JI ordering')")
              write(*,"('   -c1: generate conservation residual')")
              write(*,"('   -c2: use conservation residual')")
              write(*,"('-----------------------------------------------')")
              call exit(0)
            case default
              write(*,"('Argument ',i2,' ignored.')") iarg
            end select
          end if
        end do

!.... get user input

        call input

!.... read in the grid file

        open(unit=10,file='grid.dat',form='unformatted',status='old',err=100)
        read(10) nx, ny, nz
        write(*,*) "(nx,ny,nz) = ", nx, ny, nz
        allocate( xy(2,nx,ny), xi(nx), eta(ny), STAT=ier )
!$omp parallel
!$omp single
        numprocs = 1
!$      numprocs = OMP_GET_NUM_THREADS()
        blksize = nx*ny*8/numprocs/(1024)
        write(*,*) 'Running on ',numprocs,' processor(s).'
        write(*,*) 'Block size ', blksize,'KB  or  ',blksize/16,' pages.'
        if (blksize < 16) then
          write(*,*) 'WARNING:  Block size should be greater than 16 KB'
        end if
!$omp end single nowait
!$omp do private(i,j)
        do j = 1, ny
          do i = 1, nx
            xy(:,i,j) = zero
          end do
        end do
!$omp end do
!$omp end parallel 
        if (ier .ne. 0) call error('pot$', 'Insufficient Memory for grid$')
        read(10) (((xy(1,i,j), i = 1, nx), j = 1, ny), k = 1, nz), &
                 (((xy(2,i,j), i = 1, nx), j = 1, ny), k = 1, nz), &
                 (((      tmp, i = 1, nx), j = 1, ny), k = 1, nz)
        close(10)

!.... define the boundary limits (for the boundary corners)

        bx = nx
        by = ny

!.... make the xi grid
        
        dxi = one / float(nx-1)
        dxiinv = one / dxi
        do i = 1, nx
          xi(i) = real(i-1) * dxi
        end do

!.... make the eta grid

        deta = one / float(ny-1)
        detainv = one / deta
        do j = 1, ny
          eta(j) = real(j-1) * deta
        end do

!.... allocate storage for metrics

        allocate (m(10,nx,ny), detJ(nx,ny), STAT=ier )
        if (ier .ne. 0) call error('pot$', 'Insufficient Memory for metrics$')

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            m(:,i,j) = zero
            detJ(i,j) = zero
          end do
        end do

!.... read in the metric file

        if (metric_ji) then
          open (unit=10,file='metric.dat',form='unformatted', &
                status='old',err=110)
          read(10) (((m(idof,i,j), j=1,ny), i=1,nx), idof = 1,10)
          close(10)
        else
          open (unit=10,file='metric.dat',form='unformatted', &
                status='old',err=110)
          read(10) (m(idof,:,:), idof = 1, 10)
          close(10)
        end if

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            detJ(i,j) = m(1,i,j) * m(4,i,j) - m(3,i,j) * m(2,i,j)
          end do
        end do
!       minJ = minval(detJ)
        
!.... Allocate memory for the flow data

        if (xper .or. yper) then
          allocate( per(2,nx,ny), per2(6,max(nx,ny)), STAT=ier )
!$omp parallel do private(i,j,idof)
          do j = 1, ny
            do i = 1, nx
              do idof = 1, 2
                per(idof,i,j) = zero
              end do
            end do
            do idof = 1, 6
              per2(idof,j) = zero
            end do
          end do
!$omp end parallel do
        end if
        if (ier .ne. 0) then
          call error('npot$', 'Insufficient Memory for flow variables$')
        end if

        allocate( phi(nx,ny), res(nx,ny), mat(5,nx,ny), mult(max(nx,ny)), &
                  fact(max(nx,ny)), gphi(2,nx,ny), ggphi(3,nx,ny), &
                  A(4,nx,ny), dtl(nx,ny), p(nx,ny), gp(2,nx,ny), &
                  phis(nx,ny), spg(nx,ny), STAT=ier )
        if (ier .ne. 0) then
          call error('npot$', 'Insufficient Memory for flow variables$')
        end if

!$omp parallel do private(i,j,idof)
        do j = 1, ny
          mult(j) = zero; fact(j) = zero
          do i = 1, nx
            phi(i,j) = zero; res(i,j) = zero; mat(:,i,j) = zero
            gphi(:,i,j) = zero; ggphi(:,i,j) = zero
            A(:,i,j) = zero; dtl(i,j) = one; p(i,j) = zero; gp(:,i,j) = zero
            phis(i,j) = zero; spg(i,j) = zero
          end do
        end do

150     continue

!.... Set the initial condition

        call initial()

!.... make the sponge

        if (ispg.ne.0) then
!$omp parallel do private(i)
          do j = 1, ny
            do i = 1, nx
              spg(i,j) = zero
              if ( xi(i) .ge. xs ) then
                spg(i,j) = As * ((xi(i)-xs)/(xt-xs))**Ns
              end if
            end do
          end do
        end if

        call get_stencil( optx, dxi, gx1, gx2, gx3, gx4, gx5, gx6 )
        call get_stencil( opty, deta, gy1, gy2, gy3, gy4, gy5, gy6 )

        if (conserve.eq.1) then
          !$omp parallel do private(i)
          do j = 1, ny
            do i = 1, nx
              phi(i,j) = xy(1,i,j) ! field(i,j) ! xy(1,i,j)
            end do
          end do
        else if (conserve.eq.2) then
          allocate( res_uniform(nx,ny) )
          open(20,file='uniform.dat',form='unformatted')
          read(20) res_uniform
          close(20)
        end if

!.... Begin the main loop

        do iter = 1, niter

        call timer(cpu,start,'')

!.... set the boundary conditions

        if (conserve.ne.1) call itrbc()

!.... Compute first derivatives of field in the mapped space

        call timer(cpu1,start,'')
        call grad(ndof, nx, ny, phi, gphi, dxi, deta, &
                  optx, opty, xper, yper, lsym, rsym, bsym, tsym, carp)
        call timer(cpu1, end,'Grad')
        
!.... Compute second derivatives of field
        
        call timer(cpu1, start,'')
        call grad2(ndof, nx, ny, phi, gphi, ggphi, dxi, deta, &
                   optx, opty, xper, yper, lsym, rsym, bsym, tsym, carp)
        call timer(cpu1, end,'Grad2')

!.... write out a Plot3d file

        if (.false.) then
        open(unit=20, file='grad.dat', form='unformatted')
        write(20) nx, ny, 1
        write(20) Ma, zero, zero, zero
        write(20) (( gphi(1,i,j), i = 1, nx), j = 1, ny), &
                  (( gphi(2,i,j), i = 1, nx), j = 1, ny), &
                  ((ggphi(1,i,j), i = 1, nx), j = 1, ny), &
                  ((ggphi(2,i,j), i = 1, nx), j = 1, ny), &
                  ((ggphi(3,i,j), i = 1, nx), j = 1, ny)
        close(20)
        end if

!.... transform the gradients to physical space

        call timer(cpu1, start,'')
!$omp parallel 
!$omp do private(i,j,g1phil,g2phil,g11phil,g12phil,g22phil,u,v,t,c,cinv,Mx,My)
        do j = 1, ny
          do i = 1, nx

            g1phil  = gphi(1,i,j) * m(1,i,j) + gphi(2,i,j) * m(3,i,j)
            g2phil  = gphi(1,i,j) * m(2,i,j) + gphi(2,i,j) * m(4,i,j)
            
            g11phil = ggphi(1,i,j)       * m(1,i,j)*m(1,i,j)    + &
                      two * ggphi(2,i,j) * m(1,i,j)*m(3,i,j)    + &
                      ggphi(3,i,j)       * m(3,i,j)*m(3,i,j)    + &
                      gphi(1,i,j)        * m(5,i,j)             + &
                      gphi(2,i,j)        * m(8,i,j)
            
            g12phil = ggphi(1,i,j)       * m(1,i,j)*m(2,i,j)    + &
                      ggphi(2,i,j)       * m(1,i,j)*m(4,i,j)    + &
                      ggphi(2,i,j)       * m(2,i,j)*m(3,i,j)    + &
                      ggphi(3,i,j)       * m(3,i,j)*m(4,i,j)    + &
                      gphi(1,i,j)        * m(6,i,j)             + &
                      gphi(2,i,j)        * m(9,i,j)
            
            g22phil = ggphi(1,i,j)       * m(2,i,j)*m(2,i,j)    + &
                      two * ggphi(2,i,j) * m(2,i,j)*m(4,i,j)    + &
                      ggphi(3,i,j)       * m(4,i,j)*m(4,i,j)    + &
                      gphi(1,i,j)        * m(7,i,j)             + &
                      gphi(2,i,j)        * m(10,i,j)

!.... compute other flow quantities

            u    = g1phil
            v    = g2phil
            t    = one + gamma1 * Ma**2 * pt5 * ( one - u**2 - v**2 )
            c    = sqrt(t) / Ma
            cinv = one / c
        
            Mx = u * cinv
            My = v * cinv
        
            A(1,i,j) = (one-Mx**2)*m(1,i,j)**2 + (one-My**2)*m(2,i,j)**2 - &
                       two*Mx*My*m(1,i,j)*m(2,i,j)
            A(2,i,j) = (one-Mx**2)*m(3,i,j)**2 + (one-My**2)*m(4,i,j)**2 - &
                       two*Mx*My*m(3,i,j)*m(4,i,j)
            A(3,i,j) = (one-Mx**2)*m(5,i,j) + (one-My**2)*m(7,i,j)   - &
                       two*Mx*My*m(6,i,j)
            A(4,i,j) = (one-Mx**2)*m(8,i,j) + (one-My**2)*m(10,i,j)   - &
                       two*Mx*My*m(9,i,j)

!.... compute the local time-step

!!$         call dtcfl(nx, ny, u, v, c, m(1,:,:), m(2,:,:), &
!!$                       m(3,:,:), m(4,:,:), detJ, &
!!$                    dxi, deta, cflmax, loctime, iter, dtl)

!           dtl = sqrt( maxval(detJ) ) / sqrt(detJ)

!           dtl(i,j) = one

!============================================================================!
!     Form residual
!============================================================================!

            res(i,j) = (one - Mx**2) * g11phil + (one - My**2) * g22phil - &
                       two * Mx * My * g12phil

!.... sponge

            if (ispg.ne.0) &
                 res(i,j) = res(i,j) - spg(i,j) * ( phi(i,j) - phis(i,j) )

!.... put in the time term

            res(i,j) = dtl(i,j) * sigma * omega * res(i,j)

          end do
        end do
!$omp end do
!$omp end parallel
        call timer(cpu1,end,'RHS')

!.... smoother

        if (eps_e.ne.zero) then
          call smoother( res, phi, eps_e, nx, ny )
        end if

!.... save conservative residual

        if (conserve.eq.1) then
          open(20,file='uniform.dat',form='unformatted')
          write(20) res
          close(20)
          call exit(0)
        else if (conserve.eq.2) then
          !$omp parallel do private(i,j)
          do j = 1, ny
            do i = 1, nx
              res(i,j) = res(i,j) - res_uniform(i,j)
            end do
          end do
        end if

!.... enforce BC's on the RHS

        call timer(cpu1,start,'RHSBC')
        call rhsbc()
        call timer(cpu1,end,'RHSBC')

!.... compute the norm of the residual

        call timer(cpu1,start,'Resstat')
        call resstat()
        call timer(cpu1,end,'Resstat')

!.... write out a Plot3d file

        if (.false.) then
        open(unit=20, file='res.dat', form='unformatted')
        write(20) nx, ny, 1
        write(20) Ma, zero, zero, zero
        write(20) ((    phi(i,j), i = 1, nx), j = 1, ny), &
                  ((    res(i,j), i = 1, nx), j = 1, ny), &
                  ((        one, i = 1, nx), j = 1, ny), &
                  ((one, i = 1, nx), j = 1, ny), &
                  ((one, i = 1, nx), j = 1, ny)
        close(20)
        end if

!============================================================================!
!     Form LHS and solve
!============================================================================!

        call timer(cpu1,start,'')
        call lhs1()
        call timer(cpu1,end,'LHS1')
        call timer(cpu1,start,'')
        if (xper) then
          call penta2p_blk( nx, ny, 1, mat, res, per, per2, mult, fact ) 
        else
!         call penta2bc_blk( nx, ny, 1, mat, res, mult, fact )
          call penta2bc( nx, ny, mat, res, mult, fact )
        end if
        call timer(cpu1,end,'Solve1')
          
        if (.true.) then

        call timer(cpu1,start,'')
        call lhs2()
        call timer(cpu1,end,'LHS2')
        call timer(cpu1,start,'')

        if (yper) then
          call penta1p_blk( nx, ny, 1, mat, res, per, per2, mult, fact )
        else
          if (wakecut) then
            allocate( mat2(5,na,2*ny), res2(na,2*ny), &
                      mult2(max(na,2*ny)), fact2(max(na,2*ny)) )
            do j = 1, ny
              do i = 1, na
                do k = 1, 5
                  mat2(k,i,j) = mat(5-k+1,nx-i+1,ny-j+1)
                end do
                res2(i,j) = res(nx-i+1,ny-j+1)
              end do
            end do
            mat2(:,1:na,ny+1:2*ny) = mat(:,1:na,1:ny)
            res2(1:na,ny+1:2*ny) = res(1:na,1:ny)
!           call penta1bc_blk( na, 2*ny, 1, mat2, res2, mult2, fact2 )
            call penta1bc( na, 2*ny, mat2, res2, mult2, fact2 )
            res(1:na,1:ny) = res2(1:na,ny+1:2*ny)
            do j = 1, ny
              do i = 1, na
                res(nx-i+1,ny-j+1) = res2(i,j)
              end do
            end do
            deallocate( mat2, res2, mult2, fact2 )
!           call penta1bc_blk( (nb-1)-(na+1)+1, ny, 1, mat(:,na+1:nb-1,:), &
!                              res(na+1:nb-1,:), mult, fact )
            call penta1bc( (nb-1)-(na+1)+1, ny, mat(:,na+1:nb-1,:), &
                           res(na+1:nb-1,:), mult, fact )
          else
!           call penta1bc_blk( nx, ny, 1, mat, res, mult, fact )
            call penta1bc( nx, ny, mat, res, mult, fact )
          end if
        end if
        call timer(cpu1,end,'Solve2')

        end if
        
!.... update the potential function

!$omp parallel do private(i,j)
        do j = 1, ny
          do i = 1, nx
            phi(i,j) = phi(i,j) + res(i,j)
          end do
        end do

!.... find the maximum change

        dvmax = zero
        io = 0; jo = 0

!!$omp parallel do private(i,j,resl) reduction(max: dvmax)
        do j = 1, ny
          do i = 1, nx
            resl = abs(res(i,j))
!           dvmax = max(resl,dvmax)
            if (resl .gt. dvmax) then
              io = i
              jo = j
              dvmax = resl
            end if
          end do
        end do

        call timer(cpu,end,'-')
        write(*,20) iter, norm, im, jm, resmax, io, jo, dvmax, cpu
!       write(*,20) iter, norm, im, jm, resmax, in, jn, resmin, io, jo, dvmax 
  20    format(i4,1x,1pe13.6,2(1x,'(',i3,',',i3,')',1x,1pe13.6),1x,1pe10.3)

        end do  ! iter
        
!============================================================================!
!     Output results
!============================================================================!

        call itrbc()

        allocate( q(5,nx,ny) )

!.... Compute first derivatives of field in the mapped space

        call grad(ndof, nx, ny, phi, gphi, dxi, deta, optx, opty, &
                  xper, yper, lsym, rsym, bsym, tsym, carp)

!.... transform the gradients to physical space

!$omp parallel do private(i,j,g1phil,g2phil,u,v,t,rho)
        do j = 1, ny
          do i = 1, nx
            g1phil  = gphi(1,i,j) * m(1,i,j) + gphi(2,i,j) * m(3,i,j)
            g2phil  = gphi(1,i,j) * m(2,i,j) + gphi(2,i,j) * m(4,i,j)
            u   = g1phil
            v   = g2phil
            t   = one + gamma1 * Ma**2 * pt5 * (one - u**2 - v**2 )
            rho = t ** ( one / gamma1 )
            p(i,j)   = rho * t / (gamma * Ma**2)
            q(1,i,j) = rho
            q(2,i,j) = u
            q(3,i,j) = v
            q(4,i,j) = phi(i,j)
            q(5,i,j) = p(i,j)
          end do
        end do

        if (wakecut) then
          write(*,"(i4,1x,3(1pe16.8E3,1x))") na, xy(1,na,1), xy(2,na,1), p(na,1)
          write(*,"(i4,1x,3(1pe16.8E3,1x))") na, xy(1,nb,1), xy(2,nb,1), p(nb,1)
        endif

        if (.true.) then
        do i = nb,nx
          ia = nx - i + 1
          write(10,"(8(1pe12.4E3,1x))")  xy(1,i,1),  q(4,i,1), q(3,i,1), &
                                         xy(1,ia,1), q(4,ia,1), q(3,ia,1)
!         write(*,"(8(1pe9.2,1x))") m(1,i,1), m(2,i,1), m(3,i,1), m(4,i,1)
        end do
        end if

!.... write out a Plot3d file

        open(unit=20, file='output.q', form='unformatted')
        write(20) nx, ny, 1
        write(20) Ma, zero, zero, zero
        write(20) (((q(idof,i,j), i = 1, nx), j = 1, ny), idof = 1, 5)
        close(20)

        open(unit=20, file='output.f  ', form='unformatted')
        write(20) nx, ny, 1, 5
        write(20) (((q(idof,i,j), i = 1, nx), j = 1, ny), idof = 1, 5)
        close(20)

!.... write computational grid

        open(unit=10, file='comp.xyz', form='unformatted', status='unknown')
        write(10) nx, ny, nz
        write(10) ((( xi(i), i = 1, nx), j = 1, ny), k = 1, nz), &
                  (((eta(j), i = 1, nx), j = 1, ny), k = 1, nz), &
                  (((  zero, i = 1, nx), j = 1, ny), k = 1, nz)
        close(10)

!.... write out a restart file

        open(20,file='restart.dat',form='unformatted')
        write(20) phi
        close(20)
        
!.... write out a LNS file

        deallocate( q )
        ny2 = ny                ! watch out for pg
        allocate( q(5,nx,ny2) )

!$omp parallel do private(i,j,g1phil,g2phil,u,v,t,rho)
        do j = 1, ny2
          do i = 1, nx
            g1phil  = gphi(1,i,j) * m(1,i,j) + gphi(2,i,j) * m(3,i,j)
            g2phil  = gphi(1,i,j) * m(2,i,j) + gphi(2,i,j) * m(4,i,j)
            u   = g1phil
            v   = g2phil
            t   = one + gamma1 * Ma**2 * pt5 * (one-u**2-v**2 )
            rho = t ** ( one / gamma1 )
            p(i,j)   =  rho * t / (gamma * Ma**2)
            q(1,i,j) = rho
            q(2,i,j) = u
            q(3,i,j) = v
            q(4,i,j) = tan(lambda)
            q(5,i,j) = t
          end do
        end do

!.... write out boundary values

        open(20,file='top.pot',form='formatted')
        j = ny2
        do i = 1, nx
          write(20,*) q(1,i,j), q(2,i,j), q(3,i,j), q(4,i,j), q(5,i,j)
        end do
        close(20)

        open(20,file='right.pot',form='formatted')
        i = nx
        do j = 1, ny2
          write(20,*) q(1,i,j), q(2,i,j), q(3,i,j), q(4,i,j), q(5,i,j)
        end do
        close(20)

!.... write out the pressure gradient field

        call grad(ndof, nx, ny, p, gp, dxi, deta, optx, opty, &
                  xper, yper, lsym, rsym, bsym, tsym, carp )

        open(20,file='pg.pot',form='unformatted')
        write(20) gp(1,:,:)
        close(20)

!.... write out the LNS restart file

        open(20,file='lns.dat',form='unformatted')
        write(20) 0, zero, nx, ny2, 1, 5, zero, Ma, zero, gamma, Cv
        write(20) (((q(idof,i,j), idof = 1, 5), i = 1, nx), j = 1, ny2)
        close(20)

        if (ny2.ne.ny) then
        
!.... write the grid file

        open(unit=10, file='grid.sml', form='unformatted', status='unknown')
        write(10) nx, ny2, nz
        write(10) (((xy(1,i,j), i = 1, nx), j = 1, ny2), k = 1, nz), &
                  (((xy(2,i,j), i = 1, nx), j = 1, ny2), k = 1, nz), &
                  (((     zero, i = 1, nx), j = 1, ny2), k = 1, nz)
        close(10)

        end if
        
        stop
10      format(8(1pe13.6,1x))
100     call error('npot$','Unable to open grid file.$')
110     call error('npot$','Unable to open metric file.$')

        end

subroutine get_stencil( optx, dx, gx1, gx2, gx3, gx4, gx5, gx6)

integer :: optx
real :: dx, gx1, gx2, gx3, gx4, gx5, gx6
real :: c, w, a, b, dxinv

dxinv = one / dx

!.... seven point stencil in x

if (optx.eq.0) then
  c = 1.0 / 60.0
else if (optx.eq.-1) then
  c = 0.0
else
  w = 2.0 * 3.1415926535897932385e+0 / 12.0
  c = (w/2.0 - 2.0*Sin(w)/3.0 + Sin(2.0*w)/12.0) / &
       (5.0*Sin(w) - 4.0*Sin(2.0*w) + Sin(3.0*w))
end if

a = (2.0 + 15.0 * c) / 3.0
b = -(1.0 + 48.0 * c) / 12.0

gx1 =  -c * dxinv
gx2 =  -b * dxinv
gx3 =  -a * dxinv
gx4 =   a * dxinv
gx5 =   b * dxinv
gx6 =   c * dxinv
return
end subroutine get_stencil


subroutine timer( cpu, flag, string )

  real :: cpu
  integer :: flag
  real*4, external :: second
  character(*) :: string

  if (flag.eq.0) then
    cpu = second()
  else
    cpu = second()-cpu
#ifdef VERBOSE
    if (string(1:1).ne.'-') write(*,10) string, cpu
#endif
  end if
  return
10 format(1x,a,': ',2x,1pe10.4)
end subroutine timer
!============================================================================!
        subroutine resstat( )
!============================================================================!
        use global
        use stencil
        implicit none
!============================================================================!

        resmax = zero
        resmin = infty
        norm = zero
        im = 0; jm = 0; in = 0; jn = 0
!!$omp parallel do private(i,j,resl) reduction(+: norm) reduction(max: resmax)
        do j = 1, ny
          do i = 1, nx
!           resl = res(i,j)**2 / (sigma * omega)**2
            resl = res(i,j)**2 / (dtl(i,j) * sigma * omega)**2
            norm = norm + resl
!           resmax = max(resl,resmax)
            if (sqrt(resl) .gt. resmax) then
              im = i
              jm = j
              resmax = sqrt(resl)
            end if
            if (sqrt(resl) .lt. resmin .and. sqrt(resl) .gt. zero) then
              in = i
              jn = j
              resmin = sqrt(resl)
            end if
          end do
        end do
        norm = sqrt( norm / real(nx*ny) )
!       resmax = sqrt( resmax )
!       resmin = sqrt( resmin )

        return
        end
!============================================================================!
        subroutine rhsbc( )
!============================================================================!
        use global
        use stencil
        implicit none

!.... Riemann boundary variables

        real, allocatable :: etab(:), xib(:), ub(:), vb(:), cb(:)
        real, allocatable :: bn1(:), bn2(:), bn(:), vn(:)
        real, allocatable :: rhob(:), tb(:), pb(:), phib(:)

        integer :: ib

        real, external :: field
!============================================================================!

!.... top-bottom periodic boundary condition

        if (yper) then
          res(:,ny) = zero
        end if

!.... hold the initial values of phi

        if (top.eq.0) then
          do i = 1, bx
            res(i,ny) = phi(i,ny)-field(i,ny)
          end do
        end if
 
!.... Reimann on top boundary

!!$     if (top.eq.1) then
!!$       call grad(ndof, nx, ny, phi, g1phi, g2phi, dxi, deta, optx, opty, &
!!$                 xper, yper, lsym, rsym, bsym, tsym, carp)
!!$       
!!$       u = m1 * g1phi + n1 * g2phi 
!!$       v = m2 * g1phi + n2 * g2phi
!!$       t = one + gamma1 * Ma**2 * pt5 * ( one - u**2 - v**2 )
!!$       c = sqrt(t) / Ma
!!$
!!$       allocate( bn(nx), bn1(nx), bn2(nx), uint(nx), vint(nx), cint(nx) )
!!$       allocate( etab(nx), xib(nx), ub(nx), vb(nx), cb(nx), phib(nx) )
!!$       etab = sqrt(pt5 - x(:,ny) + pt5*sqrt((two*x(:,ny)-one)**2 + &
!!$              four * y(:,ny)**2))
!!$       xib  = y(:,ny) / etab
!!$       ub   = (etab**2 - etab + xib**2) / (xib**2 + etab**2)
!!$       vb   = xib / (xib**2 + etab**2)
!!$       cb   = sqrt(one - pt5*gamma1*Ma**2*( ub**2 + vb**2 - one )) / Ma
!!$
!!$       bn(:)  = one / sqrt( n1(:,ny)**2 + n2(:,ny)**2 )
!!$       bn1(:) = n1(:,ny) * bn
!!$       bn2(:) = n2(:,ny) * bn
!!$
!!$       uint = two * u(:,ny-1) - u(:,ny-2)
!!$       vint = two * v(:,ny-1) - v(:,ny-2)
!!$       cint = two * c(:,ny-1) - c(:,ny-2)
!!$       phib = gc1 * phi(:,ny) + ( pt5 * deta * bn * &
!!$              ( bn1 * ub + bn2 * vb  - two * cb / gamma1 + &
!!$                bn1 * uint + bn2 * vint + two * cint / gamma1 ) + &
!!$              gc2 * phi(:,ny-1) + gc3 * phi(:,ny-2) + &
!!$              gc4 * phi(:,ny-3) + gc5 * phi(:,ny-4) )
!!$       res(1:bx,ny) = phib(1:bx)
!!$       deallocate( etab, xib, ub, vb, cb, phib )
!!$       deallocate( bn, bn1, bn2, uint, vint, cint )
!!$     end if
          
!.... bottom boundary for inviscid wall

        if (wakecut) then

!.... left portion (Continuity of first derivative)

          call grad(ndof, nx, ny, phi, gphi, dxi, deta, optx, opty, &
                    xper, yper, lsym, rsym, bsym, tsym, carp)
          j = 1
          do i = 1, na
            ib = nx - i + 1
!!$          res(i,1) = m(4,i,j)*(phi(i,2)-phi(i,1)) - &
!!$                     m(4,ib,j)*(phi(ib,2)-phi(ib,1))

!!$          res(i,1) =  m(4,i,1)*(gk1*phi(i,1) +gk2*phi(i,2) +gk3*phi(i,3)) - &
!!$                     m(4,ib,1)*(gk1*phi(ib,1)+gk2*phi(ib,2)+gk3*phi(ib,3))+&
!!$            (m(2,i,1)*gphi(1,i,1) - m(2,ib,1)*gphi(1,ib,1))*deta

             res(i,1) = m(4,i,1) * ( gc1 * phi(i,1) + &
                                     gc2 * phi(i,2) + &
                                     gc3 * phi(i,3) + &
                                     gc4 * phi(i,4) + &
                                     gc5 * phi(i,5) ) - &
                        m(4,ib,1)* ( gc1 * phi(ib,1) + &
                                     gc2 * phi(ib,2) + &
                                     gc3 * phi(ib,3) + &
                                     gc4 * phi(ib,4) + &
                                     gc5 * phi(ib,5) )  + &
                      (m(2,i,1)*gphi(1,i,1) - m(2,ib,1)*gphi(1,ib,1))*deta
          end do

!.... center wall portion

          res(na+1:nb-1,1) = gc1 * phi(na+1:nb-1,1) + &
                             gc2 * phi(na+1:nb-1,2) + &
                             gc3 * phi(na+1:nb-1,3) + &
                             gc4 * phi(na+1:nb-1,4) + &
                             gc5 * phi(na+1:nb-1,5)

!!$       res(na+1:nb-1,1) = gk1 * phi(na+1:nb-1,1) + &
!!$                          gk2 * phi(na+1:nb-1,2) + &
!!$                          gk3 * phi(na+1:nb-1,3)

!.... right portion (continuity or jump condition)

          do i = nb, nx
            res(i,1) = phi(i,1) - phi(na-(i-nb),1) + circ
          end do

        else
          if (bottom.eq.0) then
            res(1:bx,1) = gc1 * phi(1:bx,1) + gc2 * phi(1:bx,2) + &
                          gc3 * phi(1:bx,3) + gc4 * phi(1:bx,4) + &
                          gc5 * phi(1:bx,5)
          end if
        end if

!.... left-right periodic boundary condition

        if (xper) then
          res(nx,:) = zero
        end if

!.... hold the initial values of phi

        if (left.eq.0) then
          res(1,1:by) = zero
        end if

        if (left.eq.2) then
          res(1,1:by) = (phi(1,1:by) - ( two * phi(2,1:by) - &
                                         phi(3,1:by) ) )
        end if

!.... hold the initial values of phi

        if (right.eq.0) then
          res(nx,1:by) = zero
        end if
        
!.... Reimann on right boundary

!!$     if (right.eq.1) then
!!$       call grad(ndof, nx, ny, phi, g1phi, g2phi, dxi, deta, optx, opty, &
!!$                 xper, yper, lsym, rsym, bsym, tsym, carp)
!!$       
!!$       u = m1 * g1phi + n1 * g2phi 
!!$       v = m2 * g1phi + n2 * g2phi
!!$       t = one + gamma1 * Ma**2 * pt5 * ( one - u**2 - v**2 )
!!$       c = sqrt(t) / Ma
!!$
!!$       allocate( bn(ny), bn1(ny), bn2(ny), uint(ny), vint(ny), cint(ny) )
!!$       allocate( etab(ny), xib(ny), ub(ny), vb(ny), cb(ny), phib(ny) )
!!$       etab = sqrt(pt5 - x(nx,:) + pt5*sqrt((two*x(nx,:)-one)**2 + &
!!$              four * y(nx,:)**2))
!!$       xib  = y(nx,:) / etab
!!$       ub   = (etab**2 - etab + xib**2) / (xib**2 + etab**2)
!!$       vb   = xib / (xib**2 + etab**2)
!!$       cb   = sqrt(one - pt5*gamma1*Ma**2*( ub**2 + vb**2 - one )) / Ma
!!$
!!$       bn(:)  = one / sqrt( m1(nx,:)**2 + m2(nx,:)**2 )
!!$       bn1(:) = m1(nx,:) * bn
!!$       bn2(:) = m2(nx,:) * bn
!!$       uint = two * u(nx-1,:) - u(nx-2,:)
!!$       vint = two * v(nx-1,:) - v(nx-2,:)
!!$       cint = two * c(nx-1,:) - c(nx-2,:)
!!$       phib = gc1 * phi(nx,:) + ( pt5 * dxi * bn * &
!!$              ( bn1 * ub + bn2 * vb - two * cb / gamma1 + &
!!$                bn1 * uint + bn2 * vint + two * cint / gamma1 ) + &
!!$               gc2 * phi(nx-1,:) + gc3 * phi(nx-2,:) + &
!!$               gc4 * phi(nx-3,:) + gc5 * phi(nx-4,:) )
!!$       res(nx,1:by) = phib(1:by)
!!$       deallocate( etab, xib, ub, vb, cb, phib )
!!$       deallocate( bn, bn1, bn2, uint, vint, cint)
!!$     end if

!..... Extrapolation on right boundary

        if (right.eq.2) then
          res(nx,1:by) = (phi(nx,1:by) - ( two * phi(nx-1,1:by) - &
                                           phi(nx-2,1:by) ) )
        end if

        return
        end

!=============================================================================!
        subroutine smoother(rl, vl, eps_e, nx, ny) 
!  
!       Fourth order explicit smoother for the NS equations.
!       From: Computational Fluid Mechanics and Heat Transfer
!             D.A. Anderson, J. C. Tannehill, Rl H. Pletcher
!             Page:  450, 495 
!
!       Written: 6-9-95
!
!       Revised: 7-9-96
!
!       Notes:   Using symmetry on left and bottom boundaries
!=============================================================================!
        use stencil
        use constants
        implicit none

        integer :: nx, ny
        real :: rl(nx,ny), vl(nx,ny), eps_e

        real :: buff(nx,ny)
        integer :: i, j
!=============================================================================!

!.... fourth-order dissipation with reduced order near the boundaries

        do j = 1, ny
          do i = 1, nx
            buff(i,j) = -1.0
          end do
        end do

!.... \eta direction
        
        do i = 1, nx

          j = 3
          rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                      vl(i,j-2) - &
                                4.0 * vl(i,j-1) + &
                                6.0 * vl(i,j  ) - &
                                4.0 * vl(i,j+1) + &
                                1.0 * vl(i,j+2) )

          j = 2
          rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                -1.0 * vl(i,j-1) + &
                                 2.0 * vl(i,j  ) - &
                                 1.0 * vl(i,j+1) )
        end do

        !$omp parallel do private(i,j)
        do j = 4, ny-3
          do i = 1, nx
            rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                fa1 * vl(i,j-3) + &
                                fa2 * vl(i,j-2) + &
                                fa3 * vl(i,j-1) + &
                                fa4 * vl(i,j  ) + &
                                fa5 * vl(i,j+1) + &
                                fa6 * vl(i,j+2) + &
                                fa7 * vl(i,j+3) )
          end do
        end do
        
        do i = 1, nx

          j = ny-2
          rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                      vl(i,j-2) - &
                                4.0 * vl(i,j-1) + &
                                6.0 * vl(i,j  ) - &
                                4.0 * vl(i,j+1) + &
                                1.0 * vl(i,j+2) )

          j = ny-1
          rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                -1.0 * vl(i,j-1) + &
                                 2.0 * vl(i,j  ) - &
                                 1.0 * vl(i,j+1) )
        end do
                                          
!.... \xi direction

        !$omp parallel do private(i,j)
        do j = 1, ny

           i = 3
           rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                      vl(i-2,j) - &
                                4.0 * vl(i-1,j) + &
                                6.0 * vl(i  ,j) - &
                                4.0 * vl(i+1,j) + &
                                1.0 * vl(i+2,j) )

           i = 2
           rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                -1.0 * vl(i-1,j) + &
                                 2.0 * vl(i,  j) - &
                                 1.0 * vl(i+1,j) )

           do i = 4, nx-3
             rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                 fa1 * vl(i-3,j) + &
                                 fa2 * vl(i-2,j) + &
                                 fa3 * vl(i-1,j) + &
                                 fa4 * vl(i  ,j) + &
                                 fa5 * vl(i+1,j) + &
                                 fa6 * vl(i+2,j) + &
                                 fa7 * vl(i+3,j) )
           end do

           i = nx-2
           rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                      vl(i-2,j) - &
                                4.0 * vl(i-1,j) + &
                                6.0 * vl(i  ,j) - &
                                4.0 * vl(i+1,j) + &
                                1.0 * vl(i+2,j) )

           i = nx-1
           rl(i,j) = rl(i,j) + eps_e * buff(i,j) * ( &
                                -1.0 * vl(i-1,j) + &
                                 2.0 * vl(i,  j) - &
                                 1.0 * vl(i+1,j) )
        end do

        return
        end

!=============================================================================!
        subroutine solve1( nsys, n, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a tridiagonal system of equations without pivoting.
!  Vectorized over the first index.
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!
!  inout:
!    mat        : the tridiagonal matrix to be solved
!    rhs        : the right hand side
!=============================================================================!
        implicit none

        integer, intent(in) :: n, nsys
        real, intent(inout) :: mat(3,nsys,n), rhs(nsys,n)
        real, intent(inout) :: mult(nsys), fact(nsys)
        
!.... useful constants

        real, parameter :: zero = 0.0, one = 1.0

!.... local variables
        
        integer :: i, p, iv

        !$omp parallel do private(iv,i,p)
        do iv = 1, nsys

          do i = 1, n - 1
            p  = i + 1
            fact(iv) = one / mat(2,iv,i)
            mult(iv) = -mat(1,iv,p) * fact(iv)
            mat(2,iv,p) = mat(2,iv,p) + mult(iv) * mat(3,iv,i)
            rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)
          end do

!.... do the last row first

          i = n
          rhs(iv,i) = rhs(iv,i) / mat(2,iv,i)
          
!.... now do the rest of the rows in reverse order

          do i = n - 1, 1, -1
            p = i + 1
            rhs(iv,i) = rhs(iv,i) - rhs(iv,p) * mat(3,iv,i)
            rhs(iv,i) = rhs(iv,i) / mat(2,iv,i)
          end do

        end do

        end subroutine solve1

!=============================================================================!
        subroutine solve2( n, nsys, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a tridiagonal system of equations without pivoting. 
!  Vectorized over the second index. 
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!
!  inout:
!    mat        : the tridiagonal matrix to be solved
!    rhs        : the right hand side
!=============================================================================!
        implicit none

        integer, intent(in) :: n, nsys
        real, intent(inout) :: mat(3,n,nsys), rhs(n,nsys)
        real, intent(inout) :: mult(nsys), fact(nsys)
        
!.... useful constants

        real, parameter :: zero = 0.0, one = 1.0

!.... local variables
        
        integer :: i, p, iv

        !$omp parallel do private(iv,i,p)
        do iv = 1, nsys

          do i = 1, n - 1
            p  = i + 1
            fact(iv) = one / mat(2,i,iv)
            mult(iv) = -mat(1,p,iv) * fact(iv)
            mat(2,p,iv) = mat(2,p,iv) + mult(iv) * mat(3,i,iv)
            rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)
          end do

!.... do the last row first

          i = n
          rhs(i,iv) = rhs(i,iv) / mat(2,i,iv)
          
!.... now do the rest of the rows in reverse order

          do i = n - 1, 1, -1
            p = i + 1
            rhs(i,iv) = rhs(i,iv) - rhs(p,iv) * mat(3,i,iv)
            rhs(i,iv) = rhs(i,iv) / mat(2,i,iv)
          end do

        end do

        end subroutine solve2
module spatial

implicit none

type derivative_type
  integer :: order
  integer :: scheme
  integer :: stencil_width
  integer, pointer :: stencil_weights(:)
  integer, pointer :: stencil_index(:)
end type derivative_type

contains

subroutine spatial_init( deriv, order, scheme )

type(derivative_type), pointer :: pderiv 

if ( associated(pderiv) ) &
     call error('spatial_init$','Derivative is already allocated$')

allocate( pderiv )
pderiv%order = order
pderiv%scheme = scheme
pderiv%stencil_width = schemes%width(scheme)
allocate( pderiv%stencil_weights(pderiv%stencil_width) )
pderiv%stencil_weights = schemes%weights(1:schemes%width(scheme))
pderiv%stencil_index(



end subroutine spatial_init

subroutine spatial_derivative( deriv, f, df )

type(derivative_type) :: deriv


integer :: nweights
real :: weights(:)
real :: shift(:)

df = zero
do iw = 1, nweights
  df = df + weights(iw) * f(:,index+shift(iw))
end do

end subroutine spatial_derivative



end module spatial
!=============================================================================!
        module stencil
!
!  Finite Difference coefficient of various orders
!
!=============================================================================!
!.... First derivatives
!=============================================================================!

!.... second order one-sided difference ( x 2 3 )

        real, parameter :: gk1 = -1.500000000000000000000
        real, parameter :: gk2 =  2.000000000000000000000
        real, parameter :: gk3 = -0.500000000000000000000

!.... third order biased difference ( 1 x 2 3 )

        real, parameter :: gl1 = -0.333333333333333333333
        real, parameter :: gl2 = -0.500000000000000000000
        real, parameter :: gl3 =  1.000000000000000000000
        real, parameter :: gl4 = -0.166666666666666666667

!.... fourth order central difference ( 1 2 x 4 5 )

        real, parameter :: ga1 =  8.333333333333333333333E-02
        real, parameter :: ga2 = -6.666666666666666666667E-01
        real, parameter :: ga3 =  6.666666666666666666667E-01
        real, parameter :: ga4 = -8.333333333333333333333E-02

!.... fourth order one-sided ( x 2 3 4 5 ) 

        real, parameter :: gc1 = -2.083333333333333333333E+00
        real, parameter :: gc2 =  4.000000000000000000000E+00
        real, parameter :: gc3 = -3.000000000000000000000E+00
        real, parameter :: gc4 =  1.333333333333333333333E+00
        real, parameter :: gc5 = -2.500000000000000000000E-01

!.... fourth order biased difference ( 1 x 2 3 4 5 )

        real, parameter :: gb1 = -2.500000000000000000000E-01
        real, parameter :: gb2 = -8.333333333333333333333E-01
        real, parameter :: gb3 =  1.500000000000000000000E+00
        real, parameter :: gb4 = -5.000000000000000000000E-01
        real, parameter :: gb5 =  8.333333333333333333333E-02

!.... sixth order one-sided ( x 2 3 4 5 6 7 )

        real, parameter :: ge1 = -2.450000000000000000000E+00
        real, parameter :: ge2 =  6.000000000000000000000E+00
        real, parameter :: ge3 = -7.500000000000000000000E+00
        real, parameter :: ge4 =  6.666666666666666666667E+00
        real, parameter :: ge5 = -3.750000000000000000000E+00
        real, parameter :: ge6 =  1.200000000000000000000E+00
        real, parameter :: ge7 = -1.666666666666666666667E-01

!.... sixth order one-pt biased ( 1 x 3 4 5 6 7 ) 

        real, parameter :: gf1 = -1.666666666666666666667E-01
        real, parameter :: gf2 = -1.283333333333333333333E+00
        real, parameter :: gf3 =  2.500000000000000000000E+00 
        real, parameter :: gf4 = -1.666666666666666666667E+00
        real, parameter :: gf5 =  8.333333333333333333333E-01
        real, parameter :: gf6 = -2.500000000000000000000E-01
        real, parameter :: gf7 =  3.333333333333333333333E-02

!==============================================================================
!.... The following stencils are Carpenter's stable and third
!.... order accurate boundary treatment for the explicit fourth
!.... order interior scheme.
!==============================================================================

!.... third order one-sided [Carpenter] ( x 2 3 4 5 6) 
  
        real, parameter :: gg1 = -1.8760320556207377229
        real, parameter :: gg2 =  3.185383225577892867
        real, parameter :: gg3 = -1.8145456794375275725
        real, parameter :: gg4 =  0.5916582410526027442
        real, parameter :: gg5 = -0.10105206800050562464
        real, parameter :: gg6 =  0.014588336428275308769

!.... third order biased [Carpenter] ( 1 x 3 4 5 ) 
  
        real, parameter :: gh1 = -0.38425423267792540204
        real, parameter :: gh2 = -0.29063894776734868107
        real, parameter :: gh3 =  0.6717647845153154114
        real, parameter :: gh4 =  0.07108165983739987271
        real, parameter :: gh5 = -0.07363071876172424507
        real, parameter :: gh6 =  0.00567745485428304409

!.... third order biased [Carpenter] ( 1 2 x 4 5 ) 
  
        real, parameter :: gi1 =  0.18288527868682620658
        real, parameter :: gi2 = -1.0800147541745551643
        real, parameter :: gi3 =  0.6578728964966252582
        real, parameter :: gi4 =  0.17761704868919314564
        real, parameter :: gi5 =  0.0767798363958275586
        real, parameter :: gi6 = -0.015140306093917004671

!.... third order biased [Carpenter] ( 1 2 3 x 5 ) 
  
        real, parameter :: gj1 = -0.03418371033652918578
        real, parameter :: gj2 =  0.22482902574010312173
        real, parameter :: gj3 = -0.8908123329284539625
        real, parameter :: gj4 =  0.16529994771003501478
        real, parameter :: gj5 =  0.6134395520875252998
        real, parameter :: gj6 = -0.07857248227268028806

!=============================================================================!
!.... Second derivatives
!=============================================================================!

!.... first order one-sided difference ( x 2 3 )

        real, parameter :: dk1 =  1.0
        real, parameter :: dk2 = -2.0
        real, parameter :: dk3 =  1.0

!.... second order biased difference ( 1 x 2 3 )

        real, parameter :: dl1 =  1.0
        real, parameter :: dl2 = -2.0
        real, parameter :: dl3 =  1.0
        real, parameter :: dl4 =  0.0

!.... fourth order central difference

        real, parameter :: da1 = -8.333333333333333333333E-02
        real, parameter :: da2 =  1.333333333333333333333E+00
        real, parameter :: da3 = -2.500000000000000000000E+00
        real, parameter :: da4 =  1.333333333333333333333E+00
        real, parameter :: da5 = -8.333333333333333333333E-02
        
!.... third order biased difference

        real, parameter :: db1 =  9.166666666666666666667E-01
        real, parameter :: db2 = -1.666666666666666666667E+00
        real, parameter :: db3 =  5.000000000000000000000E-01
        real, parameter :: db4 =  3.333333333333333333333E-01
        real, parameter :: db5 = -8.333333333333333333333E-02
        
!.... fourth order one-sided (assumes f'=0) [not smooth]

        real, parameter :: dc1 = -5.763888888888888888889E+00
        real, parameter :: dc2 =  8.000000000000000000000E+00
        real, parameter :: dc3 = -3.000000000000000000000E+00
        real, parameter :: dc4 =  8.888888888888888888889E-01
        real, parameter :: dc5 = -1.250000000000000000000E-01
        
!.... third order one-sided

        real, parameter :: dd1 =  2.916666666666666666667E+00
        real, parameter :: dd2 = -8.666666666666666666667E+00
        real, parameter :: dd3 =  9.500000000000000000000E+00
        real, parameter :: dd4 = -4.666666666666666666667E+00
        real, parameter :: dd5 =  9.166666666666666666667E-01
        
!=============================================================================!
!.... Fourth derivatives
!=============================================================================!

!.... second-order, fourth derivative

        real, parameter :: fb1 =  1.000000000000000E+00
        real, parameter :: fb2 = -4.000000000000000E+00
        real, parameter :: fb3 =  6.000000000000000E+00
        real, parameter :: fb4 = -4.000000000000000E+00
        real, parameter :: fb5 =  1.000000000000000E+00

!.... fourth-order, fourth derivative

        real, parameter :: fa1 = -1.666666666666667E-01
        real, parameter :: fa2 =  2.000000000000000E+00
        real, parameter :: fa3 = -6.500000000000000E+00
        real, parameter :: fa4 =  9.333333333333333E+00
        real, parameter :: fa5 = -6.500000000000000E+00
        real, parameter :: fa6 =  2.000000000000000E+00
        real, parameter :: fa7 = -1.666666666666667E-01
        
!.... sixth-order, fourth derivative

        real, parameter :: fc1 =  2.916666666666667E-02
        real, parameter :: fc2 = -4.000000000000000E-01
        real, parameter :: fc3 =  2.816666666666667E+00
        real, parameter :: fc4 = -8.133333333333333E+00
        real, parameter :: fc5 =  1.137500000000000E+01
        real, parameter :: fc6 = -8.133333333333333E+00
        real, parameter :: fc7 =  2.816666666666667E+00
        real, parameter :: fc8 = -4.000000000000000E-01
        real, parameter :: fc9 =  2.916666666666667E-02

        end module stencil

!=============================================================================!
        subroutine penta1bc( nsys, n, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a pentadiagonal system of equations without pivoting.
!  Vectorized over the first index.
!
!  This version includes the Boundary Treatment
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!
!  inout:
!    mat        : the pentadiagonal matrix to be solved
!    rhs        : the right hand side
!
!  Revised:  3-14-96
!=============================================================================!
        implicit none

        integer n, nsys
        real mat(5,nsys,n), rhs(nsys,n)
        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, j, l, m, p, q, r, s, t, iv
!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

!$omp parallel do private(iv,i,p,r,s,t)
        do iv = 1, nsys

!.... do the first row

        i = 1

        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,iv,i)
        
        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
        mat(5,iv,p) = mat(5,iv,p) + mult(iv) * mat(1,iv,i)
        mat(1,iv,p) = mat(1,iv,p) + mult(iv) * mat(2,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)
        
        mult(iv) = -mat(1,iv,r) * fact(iv)
        mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
        mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
        mat(4,iv,r) = mat(4,iv,r) + mult(iv) * mat(1,iv,i)
        mat(5,iv,r) = mat(5,iv,r) + mult(iv) * mat(2,iv,i)
        rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)

!.... do the second row

        i = 2
        
        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,iv,i)

        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
        mat(5,iv,p) = mat(5,iv,p) + mult(iv) * mat(1,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)

        mult(iv) = -mat(1,iv,r) * fact(iv)
        mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
        mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
        mat(4,iv,r) = mat(4,iv,r) + mult(iv) * mat(1,iv,i)
        rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)

!.... do the interior rows

        do i = 3, n - 5

          p = i + 1
          r = i + 2
          
          fact(iv) = one / mat(3,iv,i)
          
          mult(iv) = -mat(2,iv,p) * fact(iv)
          mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
          mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
          rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)
          
          mult(iv) = -mat(1,iv,r) * fact(iv)
          mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
          mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
          rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)
              
        end do          ! end of loop on i

!.... do the (n-4)th row

        i = n - 4

        p = i + 1
        r = i + 2
        s = i + 3
        t = i + 4
        
        fact(iv) = one / mat(3,iv,i)
        
        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)
        
        mult(iv) = -mat(1,iv,r) * fact(iv)
        mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
        mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
        rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)
        
        mult(iv) = -mat(5,iv,s) * fact(iv)
        mat(1,iv,s) = mat(1,iv,s) + mult(iv) * mat(4,iv,i)
        mat(2,iv,s) = mat(2,iv,s) + mult(iv) * mat(5,iv,i)
        rhs(iv,s) = rhs(iv,s) + mult(iv) * rhs(iv,i)
        
        mult(iv) = -mat(4,iv,t) * fact(iv)
        mat(5,iv,t) = mat(5,iv,t) + mult(iv) * mat(4,iv,i)
        mat(1,iv,t) = mat(1,iv,t) + mult(iv) * mat(5,iv,i)
        rhs(iv,t) = rhs(iv,t) + mult(iv) * rhs(iv,i)

!.... do the (n-3)rd row

        i = n - 3

        p = i + 1
        r = i + 2
        s = i + 3
        
        fact(iv) = one / mat(3,iv,i)

        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)

        mult(iv) = -mat(1,iv,r) * fact(iv)
        mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
        mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
        rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)
        
        mult(iv) = -mat(5,iv,s) * fact(iv)
        mat(1,iv,s) = mat(1,iv,s) + mult(iv) * mat(4,iv,i)
        mat(2,iv,s) = mat(2,iv,s) + mult(iv) * mat(5,iv,i)
        rhs(iv,s) = rhs(iv,s) + mult(iv) * rhs(iv,i)

!.... do the (n-2)nd row

        i = n - 2

        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,iv,i)

        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        mat(4,iv,p) = mat(4,iv,p) + mult(iv) * mat(5,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)

        mult(iv) = -mat(1,iv,r) * fact(iv)
        mat(2,iv,r) = mat(2,iv,r) + mult(iv) * mat(4,iv,i)
        mat(3,iv,r) = mat(3,iv,r) + mult(iv) * mat(5,iv,i)
        rhs(iv,r) = rhs(iv,r) + mult(iv) * rhs(iv,i)
        
!.... do the next-to-the-last row
        
        i = n - 1

        p = i + 1
        
        fact(iv) = one / mat(3,iv,i)
        mult(iv) = -mat(2,iv,p) * fact(iv)
        mat(3,iv,p) = mat(3,iv,p) + mult(iv) * mat(4,iv,i)
        rhs(iv,p) = rhs(iv,p) + mult(iv) * rhs(iv,i)

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        rhs(iv,i) = rhs(iv,i) / mat(3,iv,i)

!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        rhs(iv,i) = rhs(iv,i) - rhs(iv,p) * mat(4,iv,i)
        rhs(iv,i) = rhs(iv,i) / mat(3,iv,i)

!.... now do the rest of the rows in reverse order

        do i = n - 2, 3, -1
        
          p = i + 1
          r = i + 2
          
          rhs(iv,i) = rhs(iv,i) - rhs(iv,p) * mat(4,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,r) * mat(5,iv,i)
          rhs(iv,i) = rhs(iv,i) / mat(3,iv,i)

        end do
        
!.... Do the last two boundary rows

          i = 2
          p = i + 1
          r = i + 2
          s = i + 3
          
          rhs(iv,i) = rhs(iv,i) - rhs(iv,p) * mat(4,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,r) * mat(5,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,s) * mat(1,iv,i)
          rhs(iv,i) = rhs(iv,i) / mat(3,iv,i)

          i = 1
          p = i + 1
          r = i + 2
          s = i + 3
          t = i + 4
          
          rhs(iv,i) = rhs(iv,i) - rhs(iv,p) * mat(4,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,r) * mat(5,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,s) * mat(1,iv,i)
          rhs(iv,i) = rhs(iv,i) - rhs(iv,t) * mat(2,iv,i)

          rhs(iv,i) = rhs(iv,i) / mat(3,iv,i)

        end do

!=============================================================================!
        return
        end

!=============================================================================!
        subroutine penta1bc_blk( nsys, n, nblk, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a block pentadiagonal system of equations without pivoting.
!  Vectorized over the first index.
!
!  This version includes the Boundary Treatment
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!    nblk       : dimension of the blocks in each row
!
!  inout:
!    mat        : the block pentadiagonal matrix to be solved
!    rhs        : the right hand side
!
!  Revised:  7-17-95
!=============================================================================!
        implicit none

        integer n, nblk, nsys
        real mat(5,nblk,nblk,nsys,n), rhs(nblk,nsys,n)
        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, l, m, p, q, r, s, t, iv
!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

!$omp parallel do private(i,l,m,p,q,r,s,t,iv)
        do iv = 1, nsys

!.... do the first row

        i = 1
        
!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(1,l,q,iv,i) = mat(1,l,q,iv,i) + mult(iv) * mat(1,nc,q,iv,i)
                 mat(2,l,q,iv,i) = mat(2,l,q,iv,i) + mult(iv) * mat(2,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc
        
!.... for all columns
        
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(5,m,q,iv,p) = mat(5,m,q,iv,p) + mult(iv) * mat(1,nc,q,iv,i)
                 mat(1,m,q,iv,p) = mat(1,m,q,iv,p) + mult(iv) * mat(2,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * mat(1,nc,q,iv,i)
                 mat(5,m,q,iv,r) = mat(5,m,q,iv,r) + mult(iv) * mat(2,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
              
           end do

        end do                  ! end of loop on nc

!.... do the second row

        i = 2
        
!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(1,l,q,iv,i) = mat(1,l,q,iv,i) + mult(iv) * mat(1,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(5,m,q,iv,p) = mat(5,m,q,iv,p) + mult(iv) * mat(1,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * mat(1,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the interior rows

        do i = 3, n - 5

!.... do the first four columns

           do nc = 1, nblk - 1
              
              do m = nc, nblk - 1
                 l = m + 1
                 mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
                 do q = nc + 1, nblk
                    mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 end do
                 rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
              end do          
              
           end do               ! end of loop on nc
           
!.... for all columns
          
           do nc = 1, nblk
              
              p = i + 1
              r = i + 2
              
              fact(iv) = one / mat(3,nc,nc,iv,i)
              
              do m = 1, nblk
                 mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
                 do q = nc + 1, nblk
                    mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 end do
                 rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
                 
                 mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
                 do q = nc + 1, nblk
                    mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 end do
                 rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
                 
              end do
              
           end do               ! end of loop on nc
           
        end do                  ! end of loop on i

!.... do the (n-4)th row

        i = n - 4

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           s = i + 3
           t = i + 4
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(5,m,nc,iv,s) * fact(iv)
              do q = nc + 1, nblk
                 mat(5,m,q,iv,s) = mat(5,m,q,iv,s) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(1,m,q,iv,s) = mat(1,m,q,iv,s) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(2,m,q,iv,s) = mat(2,m,q,iv,s) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,s) = rhs(m,iv,s) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(4,m,nc,iv,t) * fact(iv)
              do q = nc + 1, nblk
                 mat(4,m,q,iv,t) = mat(4,m,q,iv,t) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(5,m,q,iv,t) = mat(5,m,q,iv,t) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(1,m,q,iv,t) = mat(1,m,q,iv,t) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,t) = rhs(m,iv,t) + mult(iv) * rhs(nc,iv,i)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the (n-3)rd row
        
        i = n - 3

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           s = i + 3
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(5,m,nc,iv,s) * fact(iv)
              do q = nc + 1, nblk
                 mat(5,m,q,iv,s) = mat(5,m,q,iv,s) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(1,m,q,iv,s) = mat(1,m,q,iv,s) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(2,m,q,iv,s) = mat(2,m,q,iv,s) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,s) = rhs(m,iv,s) + mult(iv) * rhs(nc,iv,i)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the (n-2)nd row

        i = n - 2

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the next-to-the-last row
        
        i = n - 1

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
           end do
           
        end do                  ! end of loop on nc

!.... do the last row

        i = n
        
        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             
           
        end do                  ! end of loop on nc

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do
        
!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

!.... now do the rest of the rows in reverse order

        do i = n - 2, 3, -1
           
           p = i + 1
           r = i + 2
           
           do m = nblk, 1, -1
              do q = m+1, nblk
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
              end do
              do q = 1, nblk
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
              end do
              rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
           end do
           
        end do
        
!.... Do the last two boundary rows

        i = 2
        p = i + 1
        r = i + 2
        s = i + 3
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,s) * mat(1,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

        i = 1
        p = i + 1
        r = i + 2
        s = i + 3
        t = i + 4
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,s) * mat(1,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,t) * mat(2,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do
        
        end do
        
        return
        end

!=============================================================================!
        subroutine penta1p_blk( nsys, np, nblk, mat, rhs, per, per2, mult, fact )
!=============================================================================!
!  
!  Solves a block pentadiagonal system of equations without pivoting.
!  Vectorized over the first index.
!
!  This routine solves a PERIODIC block pentadiagonal system.
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    np         : number of rows in the systems
!    nblk       : dimension of the blocks in each row
!
!  inout:
!    mat        : the block pentadiagonal matrix to be solved
!    rhs        : the right hand side
!=============================================================================!
        implicit none

        integer np, nblk, nsys
        real mat(5,nblk,nblk,nsys,np), rhs(nblk,nsys,np)
        real per(2,nblk,nblk,nsys,np), per2(6,nblk,nblk,nsys)
        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, l, m, n, p, q, r, iv
!=============================================================================!

!.... don't solve for the redundant nodes

        n = np - 1

!$omp parallel do private(nc,i,l,m,p,q,r,iv)
        do iv = 1, nsys

!.... setup the periodic fillin vector

        do q = 1, nblk
           do p = 1, nblk
              per(1,p,q,iv,1) = mat(1,p,q,iv,1)
              per(2,p,q,iv,1) = mat(2,p,q,iv,1)
              per(1,p,q,iv,2) = zero
              per(2,p,q,iv,2) = mat(1,p,q,iv,2)
              
              per2(1,p,q,iv)  = mat(5,p,q,iv,n-1)
              per2(2,p,q,iv)  = zero
              per2(4,p,q,iv)  = mat(4,p,q,iv,n)
              per2(5,p,q,iv)  = mat(5,p,q,iv,n)
           end do
        end do

!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

        do i = 1, n - 6

!.... do the first four columns

           do nc = 1, nblk - 1
              
              do m = nc, nblk - 1
                 l = m + 1
                 mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
                 do q = nc + 1, nblk
                    mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                    per(1,l,q,iv,i) = per(1,l,q,iv,i) + mult(iv) * per(1,nc,q,iv,i)
                    per(2,l,q,iv,i) = per(2,l,q,iv,i) + mult(iv) * per(2,nc,q,iv,i)
                 end do
                 rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
              end do          

           end do               ! end of loop on nc

!.... for all columns
          
           nc = 1
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 per(1,m,q,iv,p) = per(1,m,q,iv,p) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,m,q,iv,p) = per(2,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 per(1,m,q,iv,r) = mult(iv) * per(1,nc,q,iv,i)
                 per(2,m,q,iv,r) = mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                 per2(3,m,q,iv) = mult(iv) * mat(5,nc,q,iv,i)
                 mat(3,m,q,iv,n-1) = mat(3,m,q,iv,n-1) + mult(iv) * per(1,nc,q,iv,i)
                 mat(4,m,q,iv,n-1) = mat(4,m,q,iv,n-1) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n-1) = rhs(m,iv,n-1) + mult(iv) * rhs(nc,iv,i)
              
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                 per2(6,m,q,iv) = mult(iv) * mat(5,nc,q,iv,i)
                 mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * per(1,nc,q,iv,i)
                 mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

           end do               ! end of loop on m

           do nc = 2, nblk

              p = i + 1
              r = i + 2
              
              fact(iv) = one / mat(3,nc,nc,iv,i)
              do m = 1, nblk
                 mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
                 do q = nc + 1, nblk
                    mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                    per(1,m,q,iv,p) = per(1,m,q,iv,p) + mult(iv) * per(1,nc,q,iv,i)
                    per(2,m,q,iv,p) = per(2,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
                 end do
                 rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
                 
                 mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
                 do q = nc + 1, nblk
                    mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                    mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                    per(1,m,q,iv,r) = per(1,m,q,iv,r) + mult(iv) * per(1,nc,q,iv,i)
                    per(2,m,q,iv,r) = per(2,m,q,iv,r) + mult(iv) * per(2,nc,q,iv,i)
                 end do
                 rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the next-to-the-last row

                 mult(iv) = -per2(1,m,nc,iv) * fact(iv)
                 do q = nc + 1, nblk
                    per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                    per2(3,m,q,iv) = per2(3,m,q,iv) + mult(iv) * mat(5,nc,q,iv,i)
                    mat(3,m,q,iv,n-1) = mat(3,m,q,iv,n-1) + mult(iv) * per(1,nc,q,iv,i)
                    mat(4,m,q,iv,n-1) = mat(4,m,q,iv,n-1) + mult(iv) * per(2,nc,q,iv,i)
                 end do
                 rhs(m,iv,n-1) = rhs(m,iv,n-1) + mult(iv) * rhs(nc,iv,i)
                 
!.... the periodic stuff on the last row

                 mult(iv) = -per2(4,m,nc,iv) * fact(iv)
                 do q = nc + 1, nblk
                    per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
                 end do
                 do q = 1, nblk
                    per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                    per2(6,m,q,iv) = per2(6,m,q,iv) + mult(iv) * mat(5,nc,q,iv,i)
                    mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * per(1,nc,q,iv,i)
                    mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
                 end do
                 rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

              end do            ! end of loop on m

           end do               ! end of loop on nc
           
           do q = 1, nblk
              do p = 1, nblk
                 per2(1,p,q,iv)  = per2(2,p,q,iv)
                 per2(2,p,q,iv)  = per2(3,p,q,iv)
                 per2(4,p,q,iv)  = per2(5,p,q,iv)
                 per2(5,p,q,iv)  = per2(6,p,q,iv)
              end do
           end do

        end do                  ! end of loop on i

!====================================================================================
        i = n - 5

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 per(1,l,q,iv,i) = per(1,l,q,iv,i) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,l,q,iv,i) = per(2,l,q,iv,i) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        nc = 1
        
        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,nc,nc,iv,i)
        do m = 1, nblk
           mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
           do q = nc + 1, nblk
              mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
           end do
           do q = 1, nblk
              mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
              mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
              per(1,m,q,iv,p) = per(1,m,q,iv,p) + mult(iv) * per(1,nc,q,iv,i)
              per(2,m,q,iv,p) = per(2,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
           end do
           rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
           
           mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
           do q = nc + 1, nblk
              mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
           end do
           do q = 1, nblk
              mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
              mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
              mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * per(1,nc,q,iv,i)
              per(2,m,q,iv,r) = mult(iv) * per(2,nc,q,iv,i)
           end do
           rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the next-to-the-last row

           mult(iv) = -per2(1,m,nc,iv) * fact(iv)
           do q = nc + 1, nblk
              per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
           end do
           do q = 1, nblk
              per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
              mat(1,m,q,iv,n-1) = mat(1,m,q,iv,n-1) + mult(iv) * mat(5,nc,q,iv,i)
              mat(3,m,q,iv,n-1) = mat(3,m,q,iv,n-1) + mult(iv) * per(1,nc,q,iv,i)
              mat(4,m,q,iv,n-1) = mat(4,m,q,iv,n-1) + mult(iv) * per(2,nc,q,iv,i)
           end do
           rhs(m,iv,n-1) = rhs(m,iv,n-1) + mult(iv) * rhs(nc,iv,i)
           
!.... the periodic stuff on the last row

           mult(iv) = -per2(4,m,nc,iv) * fact(iv)
           do q = nc + 1, nblk
              per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
           end do
           do q = 1, nblk
              per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
              per2(6,m,q,iv) = mult(iv) * mat(5,nc,q,iv,i)
              mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * per(1,nc,q,iv,i)
              mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
           end do
           rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

        end do                  ! end of loop on m

        do nc = 2, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 per(1,m,q,iv,p) = per(1,m,q,iv,p) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,m,q,iv,p) = per(2,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,m,q,iv,r) = per(2,m,q,iv,r) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(1,m,q,iv,n-1) = mat(1,m,q,iv,n-1) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(3,m,q,iv,n-1) = mat(3,m,q,iv,n-1) + mult(iv) * per(1,nc,q,iv,i)
                 mat(4,m,q,iv,n-1) = mat(4,m,q,iv,n-1) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n-1) = rhs(m,iv,n-1) + mult(iv) * rhs(nc,iv,i)
              
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                 per2(6,m,q,iv) = per2(6,m,q,iv) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * per(1,nc,q,iv,i)
                 mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
        
        do q = 1, nblk
           do p = 1, nblk
              per2(1,p,q,iv)  = per2(2,p,q,iv)
              per2(4,p,q,iv)  = per2(5,p,q,iv)
              per2(5,p,q,iv)  = per2(6,p,q,iv)
           end do
        end do
        
!====================================================================================
        i = n - 4

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 per(1,l,q,iv,i) = per(1,l,q,iv,i) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,l,q,iv,i) = per(2,l,q,iv,i) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(5,m,q,iv,p) = mat(5,m,q,iv,p) + mult(iv) * per(1,nc,q,iv,i)
                 per(2,m,q,iv,p) = per(2,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * per(1,nc,q,iv,i)
                 mat(5,m,q,iv,r) = mat(5,m,q,iv,r) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(1,m,q,iv,n-1) = mat(1,m,q,iv,n-1) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(2,m,q,iv,n-1) = mat(2,m,q,iv,n-1) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(3,m,q,iv,n-1) = mat(3,m,q,iv,n-1) + mult(iv) * per(1,nc,q,iv,i)
                 mat(4,m,q,iv,n-1) = mat(4,m,q,iv,n-1) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n-1) = rhs(m,iv,n-1) + mult(iv) * rhs(nc,iv,i)
              
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(1,m,q,iv,n) = mat(1,m,q,iv,n) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * per(1,nc,q,iv,i)
                 mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
        
        do q = 1, nblk
           do p = 1, nblk
              per2(4,p,q,iv)  = per2(5,p,q,iv)
           end do
        end do

!====================================================================================
        i = n - 3

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
                 per(2,l,q,iv,i) = per(2,l,q,iv,i) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(5,m,q,iv,p) = mat(5,m,q,iv,p) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(4,m,q,iv,r) = mat(4,m,q,iv,r) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(1,m,q,iv,n) = mat(1,m,q,iv,n) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(2,m,q,iv,n) = mat(2,m,q,iv,n) + mult(iv) * mat(5,nc,q,iv,i)
                 mat(3,m,q,iv,n) = mat(3,m,q,iv,n) + mult(iv) * per(2,nc,q,iv,i)
              end do
              rhs(m,iv,n) = rhs(m,iv,n) + mult(iv) * rhs(nc,iv,i)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
        
!====================================================================================
        i = n - 2

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(5,l,q,iv,i) = mat(5,l,q,iv,i) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(4,m,q,iv,p) = mat(4,m,q,iv,p) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
              
              mult(iv) = -mat(1,m,nc,iv,r) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,iv,r) = mat(1,m,q,iv,r) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(2,m,q,iv,r) = mat(2,m,q,iv,r) + mult(iv) * mat(4,nc,q,iv,i)
                 mat(3,m,q,iv,r) = mat(3,m,q,iv,r) + mult(iv) * mat(5,nc,q,iv,i)
              end do
              rhs(m,iv,r) = rhs(m,iv,r) + mult(iv) * rhs(nc,iv,i)

           end do               ! end of loop on m

        end do                  ! end of loop on nc

!====================================================================================
        i = n - 1

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(4,l,q,iv,i) = mat(4,l,q,iv,i) + mult(iv) * mat(4,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           
           fact(iv) = one / mat(3,nc,nc,iv,i)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,iv,p) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,iv,p) = mat(2,m,q,iv,p) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              do q = 1, nblk
                 mat(3,m,q,iv,p) = mat(3,m,q,iv,p) + mult(iv) * mat(4,nc,q,iv,i)
              end do
              rhs(m,iv,p) = rhs(m,iv,p) + mult(iv) * rhs(nc,iv,i)
           end do

        end do                  ! end of loop on nc

!.... do the last row

        i = n
        
        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,iv,i) / mat(3,nc,nc,iv,i)
              do q = nc + 1, nblk
                 mat(3,l,q,iv,i) = mat(3,l,q,iv,i) + mult(iv) * mat(3,nc,q,iv,i)
              end do
              rhs(l,iv,i) = rhs(l,iv,i) + mult(iv) * rhs(nc,iv,i)
           end do             

        end do                  ! end of loop on nc

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

        i = n - 2
        p = i + 1
        r = i + 2
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

        i = n - 3
        p = i + 1
        r = i + 2
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
           end do
           do q = 1, nblk
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
              rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,n) * per(2,m,q,iv,i)
           end do
           rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
        end do

!.... now do the rest of the rows in reverse order

        do i = n - 4, 1, -1
           
           p = i + 1
           r = i + 2
           
           do m = nblk, 1, -1
              do q = m+1, nblk
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,i) * mat(3,m,q,iv,i)
              end do
              do q = 1, nblk
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,p) * mat(4,m,q,iv,i)
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,r) * mat(5,m,q,iv,i)
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,n-1) * per(1,m,q,iv,i)
                 rhs(m,iv,i) = rhs(m,iv,i) - rhs(q,iv,n  ) * per(2,m,q,iv,i)
              end do
              rhs(m,iv,i) = rhs(m,iv,i) / mat(3,m,m,iv,i)
           end do
           
        end do

!.... account for periodicity

        do q = 1, nblk
           rhs(q,iv,np) = rhs(q,iv,1)
        end do

        end do

        return
        end
!=============================================================================!
        subroutine penta2bc( n, nsys, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a pentadiagonal system of equations without pivoting.
!  Vectorized over the second index.
!
!  This version includes the Boundary Treatment
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!
!  inout:
!    mat        : the pentadiagonal matrix to be solved
!    rhs        : the right hand side
!
!  Revised:  3-14-96
!=============================================================================!
        implicit none

        integer n, nsys
        real mat(5,n,nsys), rhs(n,nsys)
        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, j, p, q, r, s, t, iv
!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

!$omp parallel do private(iv,i,p,r,s,t)
        do iv = 1, nsys

!.... do the first row

        i = 1

        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,i,iv)
        
        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
        mat(5,p,iv) = mat(5,p,iv) + mult(iv) * mat(1,i,iv)
        mat(1,p,iv) = mat(1,p,iv) + mult(iv) * mat(2,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)
        
        mult(iv) = -mat(1,r,iv) * fact(iv)
        mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
        mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
        mat(4,r,iv) = mat(4,r,iv) + mult(iv) * mat(1,i,iv)
        mat(5,r,iv) = mat(5,r,iv) + mult(iv) * mat(2,i,iv)
        rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)

!.... do the second row

        i = 2
        
        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,i,iv)

        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
        mat(5,p,iv) = mat(5,p,iv) + mult(iv) * mat(1,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)
          
        mult(iv) = -mat(1,r,iv) * fact(iv)
        mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
        mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
        mat(4,r,iv) = mat(4,r,iv) + mult(iv) * mat(1,i,iv)
        rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)

!.... do the interior rows

        do i = 3, n - 5

          p = i + 1
          r = i + 2
          
          fact(iv) = one / mat(3,i,iv)

          mult(iv) = -mat(2,p,iv) * fact(iv)
          mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
          mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
          rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)

          mult(iv) = -mat(1,r,iv) * fact(iv)
          mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
          mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
          rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)
              
        end do          ! end of loop on i

!.... do the (n-4)th row

        i = n - 4

        p = i + 1
        r = i + 2
        s = i + 3
        t = i + 4
        
        fact(iv) = one / mat(3,i,iv)
        
        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(1,r,iv) * fact(iv)
        mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
        mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
        rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(5,s,iv) * fact(iv)
        mat(1,s,iv) = mat(1,s,iv) + mult(iv) * mat(4,i,iv)
        mat(2,s,iv) = mat(2,s,iv) + mult(iv) * mat(5,i,iv)
        rhs(s,iv) = rhs(s,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(4,t,iv) * fact(iv)
        mat(5,t,iv) = mat(5,t,iv) + mult(iv) * mat(4,i,iv)
        mat(1,t,iv) = mat(1,t,iv) + mult(iv) * mat(5,i,iv)
        rhs(t,iv) = rhs(t,iv) + mult(iv) * rhs(i,iv)

!.... do the (n-3)rd row

        i = n - 3

        p = i + 1
        r = i + 2
        s = i + 3
        
        fact(iv) = one / mat(3,i,iv)

        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(1,r,iv) * fact(iv)
        mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
        mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
        rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(5,s,iv) * fact(iv)
        mat(1,s,iv) = mat(1,s,iv) + mult(iv) * mat(4,i,iv)
        mat(2,s,iv) = mat(2,s,iv) + mult(iv) * mat(5,i,iv)
        rhs(s,iv) = rhs(s,iv) + mult(iv) * rhs(i,iv)

!.... do the (n-2)nd row

        i = n - 2

        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,i,iv)

        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        mat(4,p,iv) = mat(4,p,iv) + mult(iv) * mat(5,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)

        mult(iv) = -mat(1,r,iv) * fact(iv)
        mat(2,r,iv) = mat(2,r,iv) + mult(iv) * mat(4,i,iv)
        mat(3,r,iv) = mat(3,r,iv) + mult(iv) * mat(5,i,iv)
        rhs(r,iv) = rhs(r,iv) + mult(iv) * rhs(i,iv)

!.... do the next-to-the-last row
        
        i = n - 1

        p = i + 1
        
        fact(iv) = one / mat(3,i,iv)
        mult(iv) = -mat(2,p,iv) * fact(iv)
        mat(3,p,iv) = mat(3,p,iv) + mult(iv) * mat(4,i,iv)
        rhs(p,iv) = rhs(p,iv) + mult(iv) * rhs(i,iv)

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        rhs(i,iv) = rhs(i,iv) / mat(3,i,iv)

!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        rhs(i,iv) = rhs(i,iv) - rhs(p,iv) * mat(4,i,iv)
        rhs(i,iv) = rhs(i,iv) / mat(3,i,iv)

!.... now do the rest of the rows in reverse order

        do i = n - 2, 3, -1
        
          p = i + 1
          r = i + 2
          
          rhs(i,iv) = rhs(i,iv) - rhs(p,iv) * mat(4,i,iv)
          rhs(i,iv) = rhs(i,iv) - rhs(r,iv) * mat(5,i,iv)
          rhs(i,iv) = rhs(i,iv) / mat(3,i,iv)

        end do
        
!.... Do the last two boundary rows

        i = 2
        p = i + 1
        r = i + 2
        s = i + 3
        
        rhs(i,iv) = rhs(i,iv) - rhs(p,iv) * mat(4,i,iv)
        rhs(i,iv) = rhs(i,iv) - rhs(r,iv) * mat(5,i,iv)
        rhs(i,iv) = rhs(i,iv) - rhs(s,iv) * mat(1,i,iv)
        rhs(i,iv) = rhs(i,iv) / mat(3,i,iv)
        
        i = 1
        p = i + 1
        r = i + 2
        s = i + 3
        t = i + 4
        
        rhs(i,iv) = rhs(i,iv) - rhs(p,iv) * mat(4,i,iv)
        rhs(i,iv) = rhs(i,iv) - rhs(r,iv) * mat(5,i,iv)
        rhs(i,iv) = rhs(i,iv) - rhs(s,iv) * mat(1,i,iv)
        rhs(i,iv) = rhs(i,iv) - rhs(t,iv) * mat(2,i,iv)
        rhs(i,iv) = rhs(i,iv) / mat(3,i,iv)

        end do
!=============================================================================!
        return
        end

!=============================================================================!
        subroutine penta2bc_blk( n, nsys, nblk, mat, rhs, mult, fact )
!=============================================================================!
!  
!  Solves a block pentadiagonal system of equations without pivoting.
!  Vectorized over the second index.
!
!  This version includes the Boundary Treatment
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    n          : number of rows in the systems
!    nblk       : dimension of the blocks in each row
!
!  inout:
!    mat        : the block pentadiagonal matrix to be solved
!    rhs        : the right hand side
!
!  Revised:  7-17-95
!=============================================================================!
        implicit none

        integer n, nblk, nsys
        real mat(5,nblk,nblk,n,nsys), rhs(nblk,n,nsys)
        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, j, l, m, p, q, r, s, t, iv
!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

!$omp parallel do private(i,l,m,p,q,r,s,t,iv)
        do iv = 1, nsys

!.... do the first row

        i = 1
        
!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(1,l,q,i,iv) = mat(1,l,q,i,iv) + mult(iv) * mat(1,nc,q,i,iv)
                 mat(2,l,q,i,iv) = mat(2,l,q,i,iv) + mult(iv) * mat(2,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(5,m,q,p,iv) = mat(5,m,q,p,iv) + mult(iv) * mat(1,nc,q,i,iv)
                 mat(1,m,q,p,iv) = mat(1,m,q,p,iv) + mult(iv) * mat(2,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * mat(1,nc,q,i,iv)
                 mat(5,m,q,r,iv) = mat(5,m,q,r,iv) + mult(iv) * mat(2,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the second row

        i = 2
        
!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(1,l,q,i,iv) = mat(1,l,q,i,iv) + mult(iv) * mat(1,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(5,m,q,p,iv) = mat(5,m,q,p,iv) + mult(iv) * mat(1,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * mat(1,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
              
           end do

        end do                  ! end of loop on nc

!.... do the interior rows

        do i = 3, n - 5

!.... do the first four columns

           do nc = 1, nblk - 1
              
              do m = nc, nblk - 1
                 l = m + 1
                 mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
                 do q = nc + 1, nblk
                    mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 end do
                 rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
              end do          
              
           end do               ! end of loop on nc

!.... for all columns
          
           do nc = 1, nblk
              
              p = i + 1
              r = i + 2
              
              fact(iv) = one / mat(3,nc,nc,i,iv)
              
              do m = 1, nblk
                 mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
                 do q = nc + 1, nblk
                    mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 end do
                 rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
                 
                 mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
                 do q = nc + 1, nblk
                    mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 end do
                 rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
                 
              end do
              
           end do               ! end of loop on nc
           
        end do                  ! end of loop on i

!.... do the (n-4)th row

        i = n - 4

!.... do the first four columns
        
        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             
           
        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk
           
           p = i + 1
           r = i + 2
           s = i + 3
           t = i + 4
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(5,m,nc,s,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(5,m,q,s,iv) = mat(5,m,q,s,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(1,m,q,s,iv) = mat(1,m,q,s,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(2,m,q,s,iv) = mat(2,m,q,s,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,s,iv) = rhs(m,s,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(4,m,nc,t,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(4,m,q,t,iv) = mat(4,m,q,t,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(5,m,q,t,iv) = mat(5,m,q,t,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(1,m,q,t,iv) = mat(1,m,q,t,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,t,iv) = rhs(m,t,iv) + mult(iv) * rhs(nc,i,iv)
              
           end do
           
        end do                  ! end of loop on nc

!.... do the (n-3)rd row

        i = n - 3

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           s = i + 3
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(5,m,nc,s,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(5,m,q,s,iv) = mat(5,m,q,s,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(1,m,q,s,iv) = mat(1,m,q,s,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(2,m,q,s,iv) = mat(2,m,q,s,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,s,iv) = rhs(m,s,iv) + mult(iv) * rhs(nc,i,iv)

           end do

        end do                  ! end of loop on nc

!.... do the (n-2)nd row

        i = n - 2

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)
              
           end do

        end do                  ! end of loop on nc

!.... do the next-to-the-last row
        
        i = n - 1

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
           end do

        end do                  ! end of loop on nc

!.... do the last row

        i = n
        
        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

!.... now do the rest of the rows in reverse order

        do i = n - 2, 3, -1
           
           p = i + 1
           r = i + 2
           
           do m = nblk, 1, -1
              do q = m+1, nblk
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
              end do
              do q = 1, nblk
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
              end do
              rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
           end do
           
        end do
        
!.... Do the last two boundary rows

        i = 2
        p = i + 1
        r = i + 2
        s = i + 3
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,s,iv) * mat(1,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

        i = 1
        p = i + 1
        r = i + 2
        s = i + 3
        t = i + 4
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,s,iv) * mat(1,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,t,iv) * mat(2,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

        end do
        
        return
        end

!=============================================================================!
        subroutine penta2p_blk( np, nsys, nblk, mat, rhs, per, per2, mult, fact )
!=============================================================================!
!  
!  Solves a block pentadiagonal system of equations without pivoting.
!  Vectorized over the second index.
!
!  This routine solves a PERIODIC block pentadiagonal system.
!
!  WARNING: Since pivoting is not done, this algorithm could fail
!
!  input:
!    nsys       : number of systems to vectorize over
!    np         : number of rows in the systems
!    nblk       : dimension of the blocks in each row
!
!  inout:
!    mat        : the block pentadiagonal matrix to be solved
!    rhs        : the right hand side
!=============================================================================!
        implicit none

        integer np, nblk, nsys
        real mat(5,nblk,nblk,np,nsys), rhs(nblk,np,nsys)
        real per(2,nblk,nblk,np,nsys), per2(6,nblk,nblk,nsys)

        real mult(nsys), fact(nsys)
        
!.... useful constants

        real zero, one
        parameter (zero = 0.0, one = 1.0)

!.... local variables
        
        integer nc, i, l, m, n, p, q, r, iv
!=============================================================================!

!.... don't solve for the redundant nodes

        n = np - 1

!$omp parallel do private(nc,i,l,m,p,q,r,iv)
        do iv = 1, nsys

!.... setup the periodic fillin vector

        do q = 1, nblk
           do m = 1, nblk
              per(1,m,q,1,iv) = mat(1,m,q,1,iv)
              per(2,m,q,1,iv) = mat(2,m,q,1,iv)
              per(1,m,q,2,iv) = zero
              per(2,m,q,2,iv) = mat(1,m,q,2,iv)
              
              per2(1,m,q,iv)  = mat(5,m,q,n-1,iv)
              per2(2,m,q,iv)  = zero
              per2(4,m,q,iv)  = mat(4,m,q,n,iv)
              per2(5,m,q,iv)  = mat(5,m,q,n,iv)
           end do
        end do

!=============================================================================!
!                     F O R W A R D   E L I M I N A T I O N 
!=============================================================================!

        do i = 1, n - 6

!.... do the first four columns

           do nc = 1, nblk - 1
              
              do m = nc, nblk - 1
                 l = m + 1
                 mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
                 do q = nc + 1, nblk
                    mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                    per(1,l,q,i,iv) = per(1,l,q,i,iv) + mult(iv) * per(1,nc,q,i,iv)
                    per(2,l,q,i,iv) = per(2,l,q,i,iv) + mult(iv) * per(2,nc,q,i,iv)
                 end do
                 rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
              end do          

           end do               ! end of loop on nc

!.... for all columns
          
           nc = 1
           
           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(1,m,q,p,iv) = per(1,m,q,p,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,m,q,p,iv) = per(2,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(1,m,q,r,iv) = mult(iv) * per(1,nc,q,i,iv)
                 per(2,m,q,r,iv) = mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 per2(3,m,q,iv) = mult(iv) * mat(5,nc,q,i,iv)
                 mat(3,m,q,n-1,iv) = mat(3,m,q,n-1,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(4,m,q,n-1,iv) = mat(4,m,q,n-1,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n-1,iv) = rhs(m,n-1,iv) + mult(iv) * rhs(nc,i,iv)
      
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 per2(6,m,q,iv) = mult(iv) * mat(5,nc,q,i,iv)
                 mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

           end do               ! end of loop on m

           do nc = 2, nblk

              p = i + 1
              r = i + 2
              
              fact(iv) = one / mat(3,nc,nc,i,iv)
              do m = 1, nblk
                 mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
                 do q = nc + 1, nblk
                    mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                    per(1,m,q,p,iv) = per(1,m,q,p,iv) + mult(iv) * per(1,nc,q,i,iv)
                    per(2,m,q,p,iv) = per(2,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
                 end do
                 rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
                 
                 mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
                 do q = nc + 1, nblk
                    mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                    per(1,m,q,r,iv) = per(1,m,q,r,iv) + mult(iv) * per(1,nc,q,i,iv)
                    per(2,m,q,r,iv) = per(2,m,q,r,iv) + mult(iv) * per(2,nc,q,i,iv)
                 end do
                 rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the next-to-the-last row

                 mult(iv) = -per2(1,m,nc,iv) * fact(iv)
                 do q = nc + 1, nblk
                    per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    per2(3,m,q,iv) = per2(3,m,q,iv) + mult(iv) * mat(5,nc,q,i,iv)
                    mat(3,m,q,n-1,iv) = mat(3,m,q,n-1,iv) + mult(iv) * per(1,nc,q,i,iv)
                    mat(4,m,q,n-1,iv) = mat(4,m,q,n-1,iv) + mult(iv) * per(2,nc,q,i,iv)
                 end do
                 rhs(m,n-1,iv) = rhs(m,n-1,iv) + mult(iv) * rhs(nc,i,iv)
        
!.... the periodic stuff on the last row

                 mult(iv) = -per2(4,m,nc,iv) * fact(iv)
                 do q = nc + 1, nblk
                    per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
                 end do
                 do q = 1, nblk
                    per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                    per2(6,m,q,iv) = per2(6,m,q,iv) + mult(iv) * mat(5,nc,q,i,iv)
                    mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * per(1,nc,q,i,iv)
                    mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
                 end do
                 rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

              end do            ! end of loop on m

           end do               ! end of loop on nc
           
           do q = 1, nblk
              do m = 1, nblk
                 per2(1,m,q,iv)  = per2(2,m,q,iv)
                 per2(2,m,q,iv)  = per2(3,m,q,iv)
                 per2(4,m,q,iv)  = per2(5,m,q,iv)
                 per2(5,m,q,iv)  = per2(6,m,q,iv)
              end do
           end do

        end do                  ! end of loop on i

!====================================================================================
        i = n - 5

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(1,l,q,i,iv) = per(1,l,q,i,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,l,q,i,iv) = per(2,l,q,i,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        nc = 1
        
        p = i + 1
        r = i + 2
        
        fact(iv) = one / mat(3,nc,nc,i,iv)
        do m = 1, nblk
           mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
           do q = nc + 1, nblk
              mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
           end do
           do q = 1, nblk
              mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
              mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
              per(1,m,q,p,iv) = per(1,m,q,p,iv) + mult(iv) * per(1,nc,q,i,iv)
              per(2,m,q,p,iv) = per(2,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
           end do
           rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
           
           mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
           do q = nc + 1, nblk
              mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
           end do
           do q = 1, nblk
              mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
              mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
              mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * per(1,nc,q,i,iv)
              per(2,m,q,r,iv) = mult(iv) * per(2,nc,q,i,iv)
           end do
           rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the next-to-the-last row

           mult(iv) = -per2(1,m,nc,iv) * fact(iv)
           do q = nc + 1, nblk
              per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
           end do
           do q = 1, nblk
              per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
              mat(1,m,q,n-1,iv) = mat(1,m,q,n-1,iv) + mult(iv) * mat(5,nc,q,i,iv)
              mat(3,m,q,n-1,iv) = mat(3,m,q,n-1,iv) + mult(iv) * per(1,nc,q,i,iv)
              mat(4,m,q,n-1,iv) = mat(4,m,q,n-1,iv) + mult(iv) * per(2,nc,q,i,iv)
           end do
           rhs(m,n-1,iv) = rhs(m,n-1,iv) + mult(iv) * rhs(nc,i,iv)
      
!.... the periodic stuff on the last row

           mult(iv) = -per2(4,m,nc,iv) * fact(iv)
           do q = nc + 1, nblk
              per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
           end do
           do q = 1, nblk
              per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
              per2(6,m,q,iv) = mult(iv) * mat(5,nc,q,i,iv)
              mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * per(1,nc,q,i,iv)
              mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
           end do
           rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

        end do                  ! end of loop on m

        do nc = 2, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(1,m,q,p,iv) = per(1,m,q,p,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,m,q,p,iv) = per(2,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,m,q,r,iv) = per(2,m,q,r,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 per2(2,m,q,iv) = per2(2,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(1,m,q,n-1,iv) = mat(1,m,q,n-1,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(3,m,q,n-1,iv) = mat(3,m,q,n-1,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(4,m,q,n-1,iv) = mat(4,m,q,n-1,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n-1,iv) = rhs(m,n-1,iv) + mult(iv) * rhs(nc,i,iv)
              
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 per2(6,m,q,iv) = per2(6,m,q,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
        
        do q = 1, nblk
           do m = 1, nblk
              per2(1,m,q,iv)  = per2(2,m,q,iv)
              per2(4,m,q,iv)  = per2(5,m,q,iv)
              per2(5,m,q,iv)  = per2(6,m,q,iv)
           end do
        end do
        
!====================================================================================
        i = n - 4

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(1,l,q,i,iv) = per(1,l,q,i,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,l,q,i,iv) = per(2,l,q,i,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(5,m,q,p,iv) = mat(5,m,q,p,iv) + mult(iv) * per(1,nc,q,i,iv)
                 per(2,m,q,p,iv) = per(2,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(5,m,q,r,iv) = mat(5,m,q,r,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the next-to-the-last row

              mult(iv) = -per2(1,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(1,m,q,iv) = per2(1,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(1,m,q,n-1,iv) = mat(1,m,q,n-1,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(2,m,q,n-1,iv) = mat(2,m,q,n-1,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(3,m,q,n-1,iv) = mat(3,m,q,n-1,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(4,m,q,n-1,iv) = mat(4,m,q,n-1,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n-1,iv) = rhs(m,n-1,iv) + mult(iv) * rhs(nc,i,iv)
              
!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 per2(5,m,q,iv) = per2(5,m,q,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(1,m,q,n,iv) = mat(1,m,q,n,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * per(1,nc,q,i,iv)
                 mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
        
        do q = 1, nblk
           do m = 1, nblk
              per2(4,m,q,iv)  = per2(5,m,q,iv)
           end do
        end do

!====================================================================================
        i = n - 3

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 per(2,l,q,i,iv) = per(2,l,q,i,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(5,m,q,p,iv) = mat(5,m,q,p,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(4,m,q,r,iv) = mat(4,m,q,r,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

!.... the periodic stuff on the last row

              mult(iv) = -per2(4,m,nc,iv) * fact(iv)
              do q = nc + 1, nblk
                 per2(4,m,q,iv) = per2(4,m,q,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(1,m,q,n,iv) = mat(1,m,q,n,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(2,m,q,n,iv) = mat(2,m,q,n,iv) + mult(iv) * mat(5,nc,q,i,iv)
                 mat(3,m,q,n,iv) = mat(3,m,q,n,iv) + mult(iv) * per(2,nc,q,i,iv)
              end do
              rhs(m,n,iv) = rhs(m,n,iv) + mult(iv) * rhs(nc,i,iv)

           end do               ! end of loop on m

        end do                  ! end of loop on nc
          
!====================================================================================
        i = n - 2

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(5,l,q,i,iv) = mat(5,l,q,i,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           r = i + 2
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(4,m,q,p,iv) = mat(4,m,q,p,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
              
              mult(iv) = -mat(1,m,nc,r,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(1,m,q,r,iv) = mat(1,m,q,r,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(2,m,q,r,iv) = mat(2,m,q,r,iv) + mult(iv) * mat(4,nc,q,i,iv)
                 mat(3,m,q,r,iv) = mat(3,m,q,r,iv) + mult(iv) * mat(5,nc,q,i,iv)
              end do
              rhs(m,r,iv) = rhs(m,r,iv) + mult(iv) * rhs(nc,i,iv)

           end do               ! end of loop on m

        end do                  ! end of loop on nc

!====================================================================================
        i = n - 1

!.... do the first four columns

        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(4,l,q,i,iv) = mat(4,l,q,i,iv) + mult(iv) * mat(4,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!.... for all columns
          
        do nc = 1, nblk

           p = i + 1
           
           fact(iv) = one / mat(3,nc,nc,i,iv)
           
           do m = 1, nblk
              mult(iv) = -mat(2,m,nc,p,iv) * fact(iv)
              do q = nc + 1, nblk
                 mat(2,m,q,p,iv) = mat(2,m,q,p,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              do q = 1, nblk
                 mat(3,m,q,p,iv) = mat(3,m,q,p,iv) + mult(iv) * mat(4,nc,q,i,iv)
              end do
              rhs(m,p,iv) = rhs(m,p,iv) + mult(iv) * rhs(nc,i,iv)
           end do

        end do                  ! end of loop on nc

!.... do the last row

        i = n
        
        do nc = 1, nblk - 1
           
           do m = nc, nblk - 1
              l = m + 1
              mult(iv) = -mat(3,l,nc,i,iv) / mat(3,nc,nc,i,iv)
              do q = nc + 1, nblk
                 mat(3,l,q,i,iv) = mat(3,l,q,i,iv) + mult(iv) * mat(3,nc,q,i,iv)
              end do
              rhs(l,i,iv) = rhs(l,i,iv) + mult(iv) * rhs(nc,i,iv)
           end do             

        end do                  ! end of loop on nc

!=============================================================================!
!                   B A C K W A R D   S U B S T I T U T I O N 
!=============================================================================!

!.... do the last row first

        i = n
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

!.... do the next-to-the-last row

        i = n - 1
        p = i + 1
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

        i = n - 2
        p = i + 1
        r = i + 2
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

        i = n - 3
        p = i + 1
        r = i + 2
        
        do m = nblk, 1, -1
           do q = m+1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
           end do
           do q = 1, nblk
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
              rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,n,iv) * per(2,m,q,i,iv)
           end do
           rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
        end do

!.... now do the rest of the rows in reverse order

        do i = n - 4, 1, -1
           
           p = i + 1
           r = i + 2
           
           do m = nblk, 1, -1
              do q = m+1, nblk
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,i,iv) * mat(3,m,q,i,iv)
              end do
              do q = 1, nblk
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,p,iv) * mat(4,m,q,i,iv)
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,r,iv) * mat(5,m,q,i,iv)
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,n-1,iv) * per(1,m,q,i,iv)
                 rhs(m,i,iv) = rhs(m,i,iv) - rhs(q,n,iv) * per(2,m,q,i,iv)
              end do
              rhs(m,i,iv) = rhs(m,i,iv) / mat(3,m,m,i,iv)
           end do
           
        end do

!.... account for periodicity

        do q = 1, nblk
           rhs(q,np,iv) = rhs(q,1,iv)
        end do

        end do

        return
        end
